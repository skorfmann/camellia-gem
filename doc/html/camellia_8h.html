<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Camellia: camellia.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>camellia.h File Reference</h1>Camellia Image Processing Library header file. <a href="#_details">More...</a>
<p>

<p>
<a href="camellia_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamROI.html">CamROI</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The IPL Region Of Interest structure.  <a href="structCamROI.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamPoint.html">CamPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The structure used to identify a point in 2D.  <a href="structCamPoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamImage.html">CamImage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The famous IplImage/CamImage structure, today's standard structure for image processing.  <a href="structCamImage.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamArithmParams.html">CamArithmParams</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the parameter structure for the arithmetic computation kernel.  <a href="structCamArithmParams.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamTable.html">CamTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel table (LUT (Look-Up Table) and histogram) structure.  <a href="structCamTable.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the parameter structure for the morpho maths kernel.  <a href="structCamMorphoMathsKernel.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamLabelingResults.html">CamLabelingResults</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data structure containing the result of pixel-based labeling.  <a href="structCamLabelingResults.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamRun.html">CamRun</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structCamRun.html" title="The CamRun structure, basic element of a Run-Length Encoding (RLE) of an image.">CamRun</a> structure, basic element of a Run-Length Encoding (RLE) of an image.  <a href="structCamRun.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamBlobInfo.html">CamBlobInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Blob (block of bits) Information Structure. This is the most important result of Labeling + Blob analysis.  <a href="structCamBlobInfo.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamBlobs.html">CamBlobs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The result of any blob analysis. Essentially an array of <a class="el" href="structCamBlobInfo.html" title="The Blob (block of bits) Information Structure. This is the most important result...">CamBlobInfo</a>.  <a href="structCamBlobs.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamRLEImage.html">CamRLEImage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> structure : the RLE (Run Length Encoded) image structure.  <a href="structCamRLEImage.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamMeasuresResults.html">CamMeasuresResults</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The structure containing the result of measuring.  <a href="structCamMeasuresResults.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamVolbergFwdParams.html">CamVolbergFwdParams</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The structure to provide to the Volberg's algorithm : two functions.  <a href="structCamVolbergFwdParams.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamWarpingParams.html">CamWarpingParams</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The parameters structure used by <a class="el" href="camellia_8h.html#ad957d473fde58077a501728e5aa8f13" title="Backward warping function.">camWarping()</a>.  <a href="structCamWarpingParams.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The parameters structure for linear filtering.  <a href="structCamLinearFilterKernel.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The parameters structure for linear filtering.  <a href="structCamSepFilterKernel.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamBasin.html">CamBasin</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The structure defining a basin.  <a href="structCamBasin.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamTableOfBasins.html">CamTableOfBasins</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The table of basins structure. Simply a dynamic size array of <code><a class="el" href="structCamBasin.html" title="The structure defining a basin.">CamBasin</a></code>.  <a href="structCamTableOfBasins.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamKeypoint.html">CamKeypoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Keypoint structure.  <a href="structCamKeypoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamAffineTransform.html">CamAffineTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affine Transform parameters.  <a href="structCamAffineTransform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamKeypointsMatches.html">CamKeypointsMatches</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A match between 2 <a class="el" href="structCamKeypoints.html" title="The CamKeypoints structure.">CamKeypoints</a>.  <a href="structCamKeypointsMatches.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamKeypoints.html">CamKeypoints</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structCamKeypoints.html" title="The CamKeypoints structure.">CamKeypoints</a> structure.  <a href="structCamKeypoints.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamKeypointsKdTree.html">CamKeypointsKdTree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structCamKeypointsKdTree.html" title="The CamKeypointsKdTree class.">CamKeypointsKdTree</a> class.  <a href="structCamKeypointsKdTree.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCamBitmapFont.html">CamBitmapFont</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bitmap font structure.  <a href="structCamBitmapFont.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Histogram computation</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="213071fd53110bd85692956e71d4b537"></a><!-- doxytag: member="camellia.h::CAM_EQUAL_PERFECT" ref="213071fd53110bd85692956e71d4b537" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_EQUAL_PERFECT</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d34d6f83e2bf632b9bc5175f39b1192"></a><!-- doxytag: member="camellia.h::CAM_EQUAL_FAST" ref="6d34d6f83e2bf632b9bc5175f39b1192" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_EQUAL_FAST</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#2c8d0d19b76ab2b70bdb0863d265bc26">camHistogram</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, <a class="el" href="structCamTable.html">CamTable</a> *histo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The classical image histogramming.  <a href="#2c8d0d19b76ab2b70bdb0863d265bc26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#c0e2148995a8b6f897c30bfa8687dc07">camHistogramEqualization</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamTable.html">CamTable</a> *src_histo, int option, <a class="el" href="structCamImage.html">CamImage</a> *work)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Histogram Equalization.  <a href="#c0e2148995a8b6f897c30bfa8687dc07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#de060106e377a48e599e782eb0331e81">camHistogram2Channels</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int ch1, int ch2, <a class="el" href="structCamImage.html">CamImage</a> *result, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two channels histogram computation.  <a href="#de060106e377a48e599e782eb0331e81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce8f5c621078474e934a52b895ce9f1d"></a><!-- doxytag: member="camellia.h::camFindThreshold" ref="ce8f5c621078474e934a52b895ce9f1d" args="(CamTable *histo, int percent)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#ce8f5c621078474e934a52b895ce9f1d">camFindThreshold</a> (<a class="el" href="structCamTable.html">CamTable</a> *histo, int percent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the threshold for a given percentage of pixels. <br></td></tr>
<tr><td colspan="2"><br><h2>Warping functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27266dba15ba05d2bfefbe845fa4d5dd"></a><!-- doxytag: member="camellia.h::CAM_NN_INTERPOLATION" ref="27266dba15ba05d2bfefbe845fa4d5dd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_NN_INTERPOLATION</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1f248ecd294c04007474f666b2f3c1b"></a><!-- doxytag: member="camellia.h::CAM_BILINEAR_INTERPOLATION" ref="d1f248ecd294c04007474f666b2f3c1b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_BILINEAR_INTERPOLATION</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#78547e1ee667ba06ec613ea7e1a9a132">camVolbergFwdScanline</a> (CAM_PIXEL *in, int inlen, CAM_PIXEL *out, int outlen, double f[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Warping using Volberg's algorithm.  <a href="#78547e1ee667ba06ec613ea7e1a9a132"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#748bad57cb453f2394a2f2a287993553">camVolbergFwd</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamVolbergFwdParams.html">CamVolbergFwdParams</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for using Volberg's warping algorithm.  <a href="#748bad57cb453f2394a2f2a287993553"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#ad957d473fde58077a501728e5aa8f13">camWarping</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamWarpingParams.html">CamWarpingParams</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Backward warping function.  <a href="#ad957d473fde58077a501728e5aa8f13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#d35645928b902a2716cd4d3d79799970">camScale</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scaling function.  <a href="#d35645928b902a2716cd4d3d79799970"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e5fc20f5cc875aa8019b2552c23bdc3"></a><!-- doxytag: member="camellia.h::camWarpingSuperSampling" ref="1e5fc20f5cc875aa8019b2552c23bdc3" args="(CamImage *source, CamImage *dest, CamWarpingParams *params)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camWarpingSuperSampling</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamWarpingParams.html">CamWarpingParams</a> *params)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#1dddcefcb50d0e498810bfc075cd6533">camIntersectionSegments</a> (<a class="el" href="structCamPoint.html">CamPoint</a> p[4], <a class="el" href="structCamPoint.html">CamPoint</a> *res)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple helper function, used by <a class="el" href="camellia_8h.html#ad957d473fde58077a501728e5aa8f13" title="Backward warping function.">camWarping()</a>.  <a href="#1dddcefcb50d0e498810bfc075cd6533"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Linear filtering kernel</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54c38ac89def546efc4c71d4aad1a22e"></a><!-- doxytag: member="camellia.h::CamSobel3x3" ref="54c38ac89def546efc4c71d4aad1a22e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CamSobel3x3</b>&nbsp;&nbsp;&nbsp;camSobel</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="61a443933928f0d2386f69ae1a7a22cc"></a><!-- doxytag: member="camellia.h::CamSobelAbs3x3" ref="61a443933928f0d2386f69ae1a7a22cc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CamSobelAbs3x3</b>&nbsp;&nbsp;&nbsp;camSobelAbs</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9b6ad4f25786962f25e9cf3b7875595"></a><!-- doxytag: member="camellia.h::CAM_LINEAR_FILTER_KERNEL_MAX_SIZE" ref="e9b6ad4f25786962f25e9cf3b7875595" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_LINEAR_FILTER_KERNEL_MAX_SIZE</b>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53f834021b224685dab0f9ec7f601f81"></a><!-- doxytag: member="camellia.h::CAM_SOBEL_H" ref="53f834021b224685dab0f9ec7f601f81" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_SOBEL_H</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e41b282a9553365a01e641c203c9daee"></a><!-- doxytag: member="camellia.h::CAM_SOBEL_V" ref="e41b282a9553365a01e641c203c9daee" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_SOBEL_V</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7adb2d56e3a32da2f2e954e056c500ce"></a><!-- doxytag: member="camellia.h::CAM_GAUSSIAN_3x3" ref="7adb2d56e3a32da2f2e954e056c500ce" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_GAUSSIAN_3x3</b>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a07d78beed1bdab57b0633de813ffa94"></a><!-- doxytag: member="camellia.h::CAM_GAUSSIAN_5x5" ref="a07d78beed1bdab57b0633de813ffa94" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_GAUSSIAN_5x5</b>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b2d3a80a87c24cf0cb215a2aee9b5ce"></a><!-- doxytag: member="camellia.h::CAM_GAUSSIAN_7x7" ref="7b2d3a80a87c24cf0cb215a2aee9b5ce" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_GAUSSIAN_7x7</b>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7289c8b2f998bec82522d1eacf306fc"></a><!-- doxytag: member="camellia.h::CAM_SCHARR_H" ref="f7289c8b2f998bec82522d1eacf306fc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_SCHARR_H</b>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7c0cec2cfae5b7f6d8b3b48f5fc18cbe"></a><!-- doxytag: member="camellia.h::CAM_SCHARR_V" ref="7c0cec2cfae5b7f6d8b3b48f5fc18cbe" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_SCHARR_V</b>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#de3c164ac56119fc763e7b3060cba706">camLinearFilter3x3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Linear Filtering function  <a href="#de3c164ac56119fc763e7b3060cba706"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#5dca8ce13c5257c51f680383ede892bd">camLinearFilter5x5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5x5 Linear Filtering function  <a href="#5dca8ce13c5257c51f680383ede892bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#2dd8fc9c63273b19eafe861814e207a3">camLinearFilterAbs3x3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Linear Filtering function (absolute)  <a href="#2dd8fc9c63273b19eafe861814e207a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#786ba4a350d731400324e2d98a1194ff">camLinearFilterAbs5x5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5x5 Linear Filtering function (absolute)  <a href="#786ba4a350d731400324e2d98a1194ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#c4ff2c7004422882592e56e30245ae80">camSepFilter3x3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Linear Filtering function with a separable kernel  <a href="#c4ff2c7004422882592e56e30245ae80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#d3f008ee8a5885f955273fdcde72a105">camSepFilterAbs3x3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Linear Filtering function with a separable kernel (absolute value)  <a href="#d3f008ee8a5885f955273fdcde72a105"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#85fc004b87bd87bdba6bb8a1f597aeb7">camSepFilter5x5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5x5 Linear Filtering function with a separable kernel  <a href="#85fc004b87bd87bdba6bb8a1f597aeb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#33145b07e332bafe9dad7cee22ead5df">camSepFilterAbs5x5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5x5 Linear Filtering function with a separable kernel (absolute value)  <a href="#33145b07e332bafe9dad7cee22ead5df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#bcd6d660fc22ead9c89038345e378b83">camSepFilter7x7</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">7x7 Linear Filtering function with a separable kernel  <a href="#bcd6d660fc22ead9c89038345e378b83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#9d331944cb5958c8da918d9f8fa17f87">camSepFilterAbs7x7</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">7x7 Linear Filtering function with a separable kernel (absolute value)  <a href="#9d331944cb5958c8da918d9f8fa17f87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#4bd1a772ca2635653c867ed63abf80d4">camSobelH</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Horizontal Sobel Filter. Detects horizontal edges.  <a href="#4bd1a772ca2635653c867ed63abf80d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#42707f0ff29d6e629c46fe1b96b78d20">camSobelHAbs</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Horizontal Sobel Filter (absolute). Detects horizontal edges.  <a href="#42707f0ff29d6e629c46fe1b96b78d20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#925277229ae31d55a76bc54ad8d3f4bd">camSobelV</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Vertical Sobel Filter. Detects Vertical edges.  <a href="#925277229ae31d55a76bc54ad8d3f4bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#345e98b33f2ad94c87129acdfc539bfe">camSobelVAbs</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Vertical Sobel Filter (absolute). Detects Vertical edges.  <a href="#345e98b33f2ad94c87129acdfc539bfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#099ac7ec4a0693a86314fb3eaabaf017">camFixedFilter</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, int filter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linear convolution with a predefined kernel.  <a href="#099ac7ec4a0693a86314fb3eaabaf017"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d0d4e8258ed13454a5ce1c130512d3f"></a><!-- doxytag: member="camellia.h::camScharrH" ref="5d0d4e8258ed13454a5ce1c130512d3f" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camScharrH</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6bb12d75dfdbbad5f24037fe2b2a5a5"></a><!-- doxytag: member="camellia.h::camScharrV" ref="b6bb12d75dfdbbad5f24037fe2b2a5a5" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camScharrV</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14e4bc07c9104fbcd6348e68efbc2b34"></a><!-- doxytag: member="camellia.h::camScharrHAbs" ref="14e4bc07c9104fbcd6348e68efbc2b34" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camScharrHAbs</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9aaee97051b3c0c123a679eab8ee1053"></a><!-- doxytag: member="camellia.h::camScharrVAbs" ref="9aaee97051b3c0c123a679eab8ee1053" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camScharrVAbs</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td colspan="2"><br><h2>Median filtering kernel</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b83f8e346e6a8c822d9ef5f46f9cb628"></a><!-- doxytag: member="camellia.h::camMedianFiltering3x3" ref="b83f8e346e6a8c822d9ef5f46f9cb628" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>camMedianFiltering3x3</b>&nbsp;&nbsp;&nbsp;camMedianFilter3x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eeb66e999f3230efe636329342874a77"></a><!-- doxytag: member="camellia.h::camMedianFiltering5x5" ref="eeb66e999f3230efe636329342874a77" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>camMedianFiltering5x5</b>&nbsp;&nbsp;&nbsp;camMedianFilter5x5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#a73779e31db619f5a35c45b707ee2732">camMedianFilter3x3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 Median Filtering function  <a href="#a73779e31db619f5a35c45b707ee2732"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#0d9d8073e45c5f4ddd874acc919e16e7">camMedianFilter5x5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5x5 Median Filtering function  <a href="#0d9d8073e45c5f4ddd874acc919e16e7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Watersheding kernel</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="58257e202a2fd5c5f37fba858b936fcc"></a><!-- doxytag: member="camellia.h::CAM_NOT_COMPUTED" ref="58257e202a2fd5c5f37fba858b936fcc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_NOT_COMPUTED</b>&nbsp;&nbsp;&nbsp;65536</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#7d5bb74a1500990197be468f1119f274">camWatershed1D</a> (int *input, int size, int *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">1D watershed computation  <a href="#7d5bb74a1500990197be468f1119f274"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0ada0b41b9b3d5e20a8deeeb5285988"></a><!-- doxytag: member="camellia.h::camFreeTableOfBasins" ref="b0ada0b41b9b3d5e20a8deeeb5285988" args="(CamTableOfBasins *t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#b0ada0b41b9b3d5e20a8deeeb5285988">camFreeTableOfBasins</a> (<a class="el" href="structCamTableOfBasins.html">CamTableOfBasins</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a table of basins after use. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#24e77c449137eb273e6da49d84ad114a">camHierarchicalWatershed</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamTableOfBasins.html">CamTableOfBasins</a> *tob)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2D Hierarchical watershed computation  <a href="#24e77c449137eb273e6da49d84ad114a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#d6d60c91f0e41c7f367b97870913c26b">camHierarchicalWatershedContours</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamTableOfBasins.html">CamTableOfBasins</a> *tob)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2D Hierarchical watershed computation (with watershed/contours markers)  <a href="#d6d60c91f0e41c7f367b97870913c26b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#cd8315716d2699af0a2879ceee3f31ad">camHierarchicalWatershedRegions</a> (<a class="el" href="structCamImage.html">CamImage</a> *watershed, <a class="el" href="structCamTableOfBasins.html">CamTableOfBasins</a> *tob)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves regions from a watershed image.  <a href="#cd8315716d2699af0a2879ceee3f31ad"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Keypoints and Local descriptors</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f00a004f524cdec542495914e7071ad4"></a><!-- doxytag: member="camellia.h::CAM_MAX_NB_MATCHES" ref="f00a004f524cdec542495914e7071ad4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_MAX_NB_MATCHES</b>&nbsp;&nbsp;&nbsp;2048</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="be28d647502dedb264067c2aded7f010"></a><!-- doxytag: member="camellia.h::CAM_UPRIGHT" ref="be28d647502dedb264067c2aded7f010" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_UPRIGHT</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d9a3306e0cf8402576443eebe500b242"></a><!-- doxytag: member="camellia.h::camKeypointsSetParameters" ref="d9a3306e0cf8402576443eebe500b242" args="(int patchSize, int sigma, int threshGradient)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camKeypointsSetParameters</b> (int patchSize, int sigma, int threshGradient)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="24e47734b134286f05de2db740c96b7f"></a><!-- doxytag: member="camellia.h::camAllocateKeypoints" ref="24e47734b134286f05de2db740c96b7f" args="(CamKeypoints *fpoints, int nbPoints)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#24e47734b134286f05de2db740c96b7f">camAllocateKeypoints</a> (<a class="el" href="structCamKeypoints.html">CamKeypoints</a> *fpoints, int nbPoints)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keypoints allocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="06e681e9a1386744c8756d070f7efb9e"></a><!-- doxytag: member="camellia.h::camReallocateKeypoints" ref="06e681e9a1386744c8756d070f7efb9e" args="(CamKeypoints *fpoints, int nbPoints)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#06e681e9a1386744c8756d070f7efb9e">camReallocateKeypoints</a> (<a class="el" href="structCamKeypoints.html">CamKeypoints</a> *fpoints, int nbPoints)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keypoints reallocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4430338c8eb437d7d7c216f20a8e1fb8"></a><!-- doxytag: member="camellia.h::camFreeKeypoints" ref="4430338c8eb437d7d7c216f20a8e1fb8" args="(CamKeypoints *fpoints)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#4430338c8eb437d7d7c216f20a8e1fb8">camFreeKeypoints</a> (<a class="el" href="structCamKeypoints.html">CamKeypoints</a> *fpoints)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keypoints release. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96269ad40d6e7fbe1019609cffe14a58"></a><!-- doxytag: member="camellia.h::camDrawKeypoints" ref="96269ad40d6e7fbe1019609cffe14a58" args="(CamKeypoints *points, CamImage *dest, int color)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#96269ad40d6e7fbe1019609cffe14a58">camDrawKeypoints</a> (<a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points, <a class="el" href="structCamImage.html">CamImage</a> *dest, int color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw kepoints on screen. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="404b9ccff1c286c618f1e0a85d9955e7"></a><!-- doxytag: member="camellia.h::camDrawKeypoint" ref="404b9ccff1c286c618f1e0a85d9955e7" args="(CamKeypoint *point, CamImage *dest, int color)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#404b9ccff1c286c618f1e0a85d9955e7">camDrawKeypoint</a> (<a class="el" href="structCamKeypoint.html">CamKeypoint</a> *point, <a class="el" href="structCamImage.html">CamImage</a> *dest, int color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw one keypoint on screen. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#43d708768b49c7fd7d70395682df50fd">camHarris</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points, int k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Harris corner detector.  <a href="#43d708768b49c7fd7d70395682df50fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59fed4d1929b4e5a13e2f27cc24c3dc8"></a><!-- doxytag: member="camellia.h::camFindLocalMaximaCircle7" ref="59fed4d1929b4e5a13e2f27cc24c3dc8" args="(CamImage *source, CamKeypoints *points, int threshold)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#59fed4d1929b4e5a13e2f27cc24c3dc8">camFindLocalMaximaCircle7</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points, int threshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local maxima finder (Circle7 neighborhood). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="24c5e6cd5dae89458f8ec6d96bca913a"></a><!-- doxytag: member="camellia.h::camFindLocalMaximaCircle5" ref="24c5e6cd5dae89458f8ec6d96bca913a" args="(CamImage *source, CamKeypoints *points, int threshold)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#24c5e6cd5dae89458f8ec6d96bca913a">camFindLocalMaximaCircle5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points, int threshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local maxima finder (Circle5 neighborhood). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="845a27c37bd030f61e922093974bf559"></a><!-- doxytag: member="camellia.h::camFindLocalMaximaCircle3" ref="845a27c37bd030f61e922093974bf559" args="(CamImage *source, CamKeypoints *points, int threshold)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#845a27c37bd030f61e922093974bf559">camFindLocalMaximaCircle3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points, int threshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local maxima finder (Square3 neighborhood). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b70cc0998157584bbb4df573a616271f"></a><!-- doxytag: member="camellia.h::camIntegralImage" ref="b70cc0998157584bbb4df573a616271f" args="(CamImage *src, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#b70cc0998157584bbb4df573a616271f">camIntegralImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integral image computation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf35335b4fb608df1027e5c172600ca0"></a><!-- doxytag: member="camellia.h::camFastHessianDetectorFixedScale" ref="bf35335b4fb608df1027e5c172600ca0" args="(CamImage *integral, CamImage *dest, int scale)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#bf35335b4fb608df1027e5c172600ca0">camFastHessianDetectorFixedScale</a> (<a class="el" href="structCamImage.html">CamImage</a> *integral, <a class="el" href="structCamImage.html">CamImage</a> *dest, int scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast Hessian Detection (for one scale only). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bcccad316d621ae86fdb4da6bc500119"></a><!-- doxytag: member="camellia.h::camFastHessianDetector" ref="bcccad316d621ae86fdb4da6bc500119" args="(CamImage *source, CamKeypoints *points, int threshold, int options)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#bcccad316d621ae86fdb4da6bc500119">camFastHessianDetector</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points, int threshold, int options)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast Hessian Detection (for all scales). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f2e53a03e30a93bdc41238835749aca"></a><!-- doxytag: member="camellia.h::camFindKeypoint" ref="6f2e53a03e30a93bdc41238835749aca" args="(CamKeypoint *point, CamKeypoints *points, int *dist1, int *dist2)" -->
<a class="el" href="structCamKeypoint.html">CamKeypoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#6f2e53a03e30a93bdc41238835749aca">camFindKeypoint</a> (<a class="el" href="structCamKeypoint.html">CamKeypoint</a> *point, <a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points, int *dist1, int *dist2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a keypoint in a set of keypoints. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="19112fda60b52fe8402c8233d1abe4e2"></a><!-- doxytag: member="camellia.h::camAllocateKeypointsMatches" ref="19112fda60b52fe8402c8233d1abe4e2" args="(CamKeypointsMatches *matches, int nbpairs)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#19112fda60b52fe8402c8233d1abe4e2">camAllocateKeypointsMatches</a> (<a class="el" href="structCamKeypointsMatches.html">CamKeypointsMatches</a> *matches, int nbpairs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate keypoints matches. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="863e173916b6d802a081a0835efd06eb"></a><!-- doxytag: member="camellia.h::camFreeKeypointsMatches" ref="863e173916b6d802a081a0835efd06eb" args="(CamKeypointsMatches *matches)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#863e173916b6d802a081a0835efd06eb">camFreeKeypointsMatches</a> (<a class="el" href="structCamKeypointsMatches.html">CamKeypointsMatches</a> *matches)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free keypoints matches. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12b5414b38f85a3d95f85d9767c33eee"></a><!-- doxytag: member="camellia.h::camKeypointsMatching" ref="12b5414b38f85a3d95f85d9767c33eee" args="(CamKeypoints *target, CamKeypoints **models, int nbModels, CamKeypointsMatches *matches)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#12b5414b38f85a3d95f85d9767c33eee">camKeypointsMatching</a> (<a class="el" href="structCamKeypoints.html">CamKeypoints</a> *target, <a class="el" href="structCamKeypoints.html">CamKeypoints</a> **models, int nbModels, <a class="el" href="structCamKeypointsMatches.html">CamKeypointsMatches</a> *matches)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an object in a database (brute force matching). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1860041ab8f4ab29c302c85cb50b40c4"></a><!-- doxytag: member="camellia.h::camKeypointsMatching2" ref="1860041ab8f4ab29c302c85cb50b40c4" args="(CamKeypoints *points1, CamKeypoints *points2, CamKeypointsMatches *matches)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camKeypointsMatching2</b> (<a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points1, <a class="el" href="structCamKeypoints.html">CamKeypoints</a> *points2, <a class="el" href="structCamKeypointsMatches.html">CamKeypointsMatches</a> *matches)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d4206e571087ad81100f3af4c2fcb552"></a><!-- doxytag: member="camellia.h::camFindAffineTransform" ref="d4206e571087ad81100f3af4c2fcb552" args="(CamKeypointsMatches *matches, CamAffineTransform *t, int *error)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#d4206e571087ad81100f3af4c2fcb552">camFindAffineTransform</a> (<a class="el" href="structCamKeypointsMatches.html">CamKeypointsMatches</a> *matches, <a class="el" href="structCamAffineTransform.html">CamAffineTransform</a> *t, int *error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the affine transform from one object to the next. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de3766872a1f438a96140f44fe7b93f7"></a><!-- doxytag: member="camellia.h::camFindAffineTransform2" ref="de3766872a1f438a96140f44fe7b93f7" args="(CamKeypointsMatches *matches, CamAffineTransform *t, int *error)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camFindAffineTransform2</b> (<a class="el" href="structCamKeypointsMatches.html">CamKeypointsMatches</a> *matches, <a class="el" href="structCamAffineTransform.html">CamAffineTransform</a> *t, int *error)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87f18e886e6bd7861a91a47a3a18e75e"></a><!-- doxytag: member="camellia.h::camApplyAffineTransform" ref="87f18e886e6bd7861a91a47a3a18e75e" args="(CamPoint *xy, CamPoint *uv, CamAffineTransform *t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#87f18e886e6bd7861a91a47a3a18e75e">camApplyAffineTransform</a> (<a class="el" href="structCamPoint.html">CamPoint</a> *xy, <a class="el" href="structCamPoint.html">CamPoint</a> *uv, <a class="el" href="structCamAffineTransform.html">CamAffineTransform</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply an affine transform on a point (xy) to find the target point (uv). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f45f71db77b12b60be8a7cec08f644c"></a><!-- doxytag: member="camellia.h::camKeypointsMatchingKdTree" ref="5f45f71db77b12b60be8a7cec08f644c" args="(CamKeypoints *target, CamFPKdTreeNode *kdTreeRoot, CamKeypointsMatches *matches, int explore)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camKeypointsMatchingKdTree</b> (<a class="el" href="structCamKeypoints.html">CamKeypoints</a> *target, CamFPKdTreeNode *kdTreeRoot, <a class="el" href="structCamKeypointsMatches.html">CamKeypointsMatches</a> *matches, int explore)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b47fa263139a33087c06e9b81bb1a1fc"></a><!-- doxytag: member="camellia.h::camKeypointsCompileKdTree" ref="b47fa263139a33087c06e9b81bb1a1fc" args="(CamKeypoints **models, int nbModels)" -->
CamFPKdTreeNode *&nbsp;</td><td class="memItemRight" valign="bottom"><b>camKeypointsCompileKdTree</b> (<a class="el" href="structCamKeypoints.html">CamKeypoints</a> **models, int nbModels)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="225e762039ee830a534ebd2a4edcb4c1"></a><!-- doxytag: member="camellia.h::camFindKeypointKdTree" ref="225e762039ee830a534ebd2a4edcb4c1" args="(CamKeypoint *point, CamFPKdTreeNode *kdTreeRoot, int explore, int *dist1, int *dist2)" -->
<a class="el" href="structCamKeypoint.html">CamKeypoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>camFindKeypointKdTree</b> (<a class="el" href="structCamKeypoint.html">CamKeypoint</a> *point, CamFPKdTreeNode *kdTreeRoot, int explore, int *dist1, int *dist2)</td></tr>

<tr><td colspan="2"><br><h2>Utility functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2373951ac67873310cc291dbc901722"></a><!-- doxytag: member="camellia.h::camDownScaling2x2" ref="d2373951ac67873310cc291dbc901722" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>camDownScaling2x2</b>&nbsp;&nbsp;&nbsp;camDownscaling2x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9b39a833b9aab402b3bb746568cdc98b"></a><!-- doxytag: member="camellia.h::CAM_CONFIG_MAX_ENTRIES" ref="9b39a833b9aab402b3bb746568cdc98b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_CONFIG_MAX_ENTRIES</b>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14112f8eb850a9a2a130f65db5eecec9"></a><!-- doxytag: member="camellia.h::CAM_CAPTURE_AUTO_SOURCE" ref="14112f8eb850a9a2a130f65db5eecec9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_CAPTURE_AUTO_SOURCE</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c11e9752799808831bd91cc1d1596503"></a><!-- doxytag: member="camellia.h::CAM_CAPTURE_DISPLAY" ref="c11e9752799808831bd91cc1d1596503" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_CAPTURE_DISPLAY</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="452dba7afb9e536b9de9620853fc9bcc"></a><!-- doxytag: member="camellia.h::CAM_CAPTURE_USE_READ" ref="452dba7afb9e536b9de9620853fc9bcc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CAM_CAPTURE_USE_READ</b>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c8ff30574bbf3dca045140d15f6b334"></a><!-- doxytag: member="camellia.h::camErrorFunct" ref="5c8ff30574bbf3dca045140d15f6b334" args=")(char *, char *)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>camErrorFunct</b> )(char *, char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="912e006e9f07a11ec36dbf8c3219d638"></a><!-- doxytag: member="camellia.h::camAllocateImage" ref="912e006e9f07a11ec36dbf8c3219d638" args="(CamImage *image, int width, int height, int depth)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#912e006e9f07a11ec36dbf8c3219d638">camAllocateImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height, int depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grey scale image allocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f4f5e263a8d1856dc62507ef7e9a3bb"></a><!-- doxytag: member="camellia.h::camAllocateImageEx" ref="3f4f5e263a8d1856dc62507ef7e9a3bb" args="(CamImage *image, int width, int height, int depth, int color_seq)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#3f4f5e263a8d1856dc62507ef7e9a3bb">camAllocateImageEx</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height, int depth, int color_seq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Any kind of image allocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e15a79d8f2e9b6323cce0dc74fe8f02"></a><!-- doxytag: member="camellia.h::camFillImageHeader" ref="7e15a79d8f2e9b6323cce0dc74fe8f02" args="(CamImage *image, int width, int height, int depth, int channelseq)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#7e15a79d8f2e9b6323cce0dc74fe8f02">camFillImageHeader</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height, int depth, int channelseq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill image header (no memory initialization). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c4c5be480b06529eca08f1b0df99c5dc"></a><!-- doxytag: member="camellia.h::camAllocateYUVImage" ref="c4c5be480b06529eca08f1b0df99c5dc" args="(CamImage *image, int width, int height)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#c4c5be480b06529eca08f1b0df99c5dc">camAllocateYUVImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">YUV image allocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ea168982d8e14543fd55f6da04be2934"></a><!-- doxytag: member="camellia.h::camAllocateHLSImage" ref="ea168982d8e14543fd55f6da04be2934" args="(CamImage *image, int width, int height)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#ea168982d8e14543fd55f6da04be2934">camAllocateHLSImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HLS image allocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ab8678168958b15a014b09899575f6b"></a><!-- doxytag: member="camellia.h::camAllocateRGBImage" ref="9ab8678168958b15a014b09899575f6b" args="(CamImage *image, int width, int height)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#9ab8678168958b15a014b09899575f6b">camAllocateRGBImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RGB image allocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="71efb458354b38be740b155c2644463d"></a><!-- doxytag: member="camellia.h::camAllocateRGBAImage" ref="71efb458354b38be740b155c2644463d" args="(CamImage *image, int width, int height)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#71efb458354b38be740b155c2644463d">camAllocateRGBAImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RGB image allocation with alpha channel. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d6d862667b343fba17671cd0ec04060"></a><!-- doxytag: member="camellia.h::camAllocateBGRImage" ref="4d6d862667b343fba17671cd0ec04060" args="(CamImage *image, int width, int height)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#4d6d862667b343fba17671cd0ec04060">camAllocateBGRImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BGR image allocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bdaad0135b5c598ef1379690703703b4"></a><!-- doxytag: member="camellia.h::camAllocateBGRAImage" ref="bdaad0135b5c598ef1379690703703b4" args="(CamImage *image, int width, int height)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#bdaad0135b5c598ef1379690703703b4">camAllocateBGRAImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BGR image allocation with alpha channel. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f9e0cfd15d26b78ad54684acb9aafb35"></a><!-- doxytag: member="camellia.h::camDeallocateImage" ref="f9e0cfd15d26b78ad54684acb9aafb35" args="(CamImage *image)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#f9e0cfd15d26b78ad54684acb9aafb35">camDeallocateImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Image memory release. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ec824e1a11642d16688ff1c8aea54791"></a><!-- doxytag: member="camellia.h::camFreeImage" ref="ec824e1a11642d16688ff1c8aea54791" args="(CamImage *image)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#ec824e1a11642d16688ff1c8aea54791">camFreeImage</a> (<a class="el" href="structCamImage.html">CamImage</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Image memory release. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="35499ec3aab3b8bd15565f15bcbc434f"></a><!-- doxytag: member="camellia.h::camSetROI" ref="35499ec3aab3b8bd15565f15bcbc434f" args="(CamROI *roi, int coi, int xOffset, int yOffset, int width, int height)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#35499ec3aab3b8bd15565f15bcbc434f">camSetROI</a> (<a class="el" href="structCamROI.html">CamROI</a> *roi, int coi, int xOffset, int yOffset, int width, int height)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the ROI utility function. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b388099a71fda354a7de927203b5056"></a><!-- doxytag: member="camellia.h::camSetMaxROI" ref="5b388099a71fda354a7de927203b5056" args="(CamROI *roi, CamImage *image)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#5b388099a71fda354a7de927203b5056">camSetMaxROI</a> (<a class="el" href="structCamROI.html">CamROI</a> *roi, <a class="el" href="structCamImage.html">CamImage</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the ROI to the maximum size of the image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9126b44faaeaa69e7b04f0738aa7a8b9"></a><!-- doxytag: member="camellia.h::camReduceROI" ref="9126b44faaeaa69e7b04f0738aa7a8b9" args="(CamROI *roi, int pixels)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#9126b44faaeaa69e7b04f0738aa7a8b9">camReduceROI</a> (<a class="el" href="structCamROI.html">CamROI</a> *roi, int pixels)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduce the roi by a given number of pixels on each side. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2dfe31c691e6b5c8686815c1e74aba66"></a><!-- doxytag: member="camellia.h::camEnlargeROI" ref="2dfe31c691e6b5c8686815c1e74aba66" args="(CamROI *roi, int pixels)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#2dfe31c691e6b5c8686815c1e74aba66">camEnlargeROI</a> (<a class="el" href="structCamROI.html">CamROI</a> *roi, int pixels)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enlarge the roi by a given number of pixels on each side. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9a4a1542a049e0a321db75c5db12c681"></a><!-- doxytag: member="camellia.h::camZoom2x" ref="9a4a1542a049e0a321db75c5db12c681" args="(CamImage *src, CamImage *dst)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#9a4a1542a049e0a321db75c5db12c681">camZoom2x</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamImage.html">CamImage</a> *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple 2x Zoom functin (by pixels replication). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8924fb25405730e75099c28b6415693f"></a><!-- doxytag: member="camellia.h::camDecimateNN" ref="8924fb25405730e75099c28b6415693f" args="(CamImage *src, CamImage *dest, int factor)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#8924fb25405730e75099c28b6415693f">camDecimateNN</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamImage.html">CamImage</a> *dest, int factor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple nearest-neighbour decimation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0fc42c0fed9f1c909a7e3b4a97330aad"></a><!-- doxytag: member="camellia.h::camSetRLEMask" ref="0fc42c0fed9f1c909a7e3b4a97330aad" args="(CamImage *image, CamRLEImage *mask)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#0fc42c0fed9f1c909a7e3b4a97330aad">camSetRLEMask</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the image mask (Run-Length encoded mask). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73dd3205a41d8a460f1d5057124475ed"></a><!-- doxytag: member="camellia.h::camSetMask" ref="73dd3205a41d8a460f1d5057124475ed" args="(CamImage *image, CamImage *mask)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#73dd3205a41d8a460f1d5057124475ed">camSetMask</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, <a class="el" href="structCamImage.html">CamImage</a> *mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the image mask (<a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> mask). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d939ba2863df1f45fdbdd97ae404eafa"></a><!-- doxytag: member="camellia.h::camDownScaling2x2" ref="d939ba2863df1f45fdbdd97ae404eafa" args="(CamImage *src, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#d939ba2863df1f45fdbdd97ae404eafa">camDownScaling2x2</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">2x2 linear interpolation downscaling <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#7b021e7ba78039afe11819d1bc9e906b">camCopy</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy function, without any color space conversion, but able to deal with planar/pixel oriented conversion, ROIs and even masking.  <a href="#7b021e7ba78039afe11819d1bc9e906b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#1a6430576f1b718bc261009289418d9d">camClone</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple cloning function.  <a href="#1a6430576f1b718bc261009289418d9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#c5b250ed6063c5813d6ba085e7c7227e">camRefCopy</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference copy.  <a href="#c5b250ed6063c5813d6ba085e7c7227e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d88497c65ae028554a214a325a58d88"></a><!-- doxytag: member="camellia.h::camSet" ref="6d88497c65ae028554a214a325a58d88" args="(CamImage *image, int fillValue)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#6d88497c65ae028554a214a325a58d88">camSet</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int fillValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all the pixel values to <code>fillValue</code>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#29df19c4f072e54051e16dbae679d8ec">camAlphaComposite</a> (<a class="el" href="structCamImage.html">CamImage</a> *source1, <a class="el" href="structCamImage.html">CamImage</a> *source2, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alpha channel compositing.  <a href="#29df19c4f072e54051e16dbae679d8ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0cf71999d7a1fbae3c61a4dae8e3aa0a"></a><!-- doxytag: member="camellia.h::camSetBorder" ref="0cf71999d7a1fbae3c61a4dae8e3aa0a" args="(CamImage *image, int borderValue)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#0cf71999d7a1fbae3c61a4dae8e3aa0a">camSetBorder</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int borderValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the border value of an image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5adebabc6e39eaafb1ec6abc0756f8c3"></a><!-- doxytag: member="camellia.h::camClipROI" ref="5adebabc6e39eaafb1ec6abc0756f8c3" args="(CamImage *image)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#5adebabc6e39eaafb1ec6abc0756f8c3">camClipROI</a> (<a class="el" href="structCamImage.html">CamImage</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clip the roi of an image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a8f67c7fc1a9736f789a2458b8c1a3f"></a><!-- doxytag: member="camellia.h::camClip" ref="2a8f67c7fc1a9736f789a2458b8c1a3f" args="(CamROI *roi, CamImage *image)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#2a8f67c7fc1a9736f789a2458b8c1a3f">camClip</a> (<a class="el" href="structCamROI.html">CamROI</a> *roi, <a class="el" href="structCamImage.html">CamImage</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clip a ROI with respect to an image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3185c266234556bd2f120096f1f08da5"></a><!-- doxytag: member="camellia.h::camROIIntersect" ref="3185c266234556bd2f120096f1f08da5" args="(CamROI *roi1, CamROI *roi2, CamROI *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#3185c266234556bd2f120096f1f08da5">camROIIntersect</a> (<a class="el" href="structCamROI.html">CamROI</a> *roi1, <a class="el" href="structCamROI.html">CamROI</a> *roi2, <a class="el" href="structCamROI.html">CamROI</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute intersection between ROIs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="51dc31a99a239d76661624e994128532"></a><!-- doxytag: member="camellia.h::camSetImageViewer" ref="51dc31a99a239d76661624e994128532" args="(char *s)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camSetImageViewer</b> (char *s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d3a1aac17bb5d79d1d5ffa7c6d081c5"></a><!-- doxytag: member="camellia.h::camView" ref="9d3a1aac17bb5d79d1d5ffa7c6d081c5" args="(CamImage *image)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#9d3a1aac17bb5d79d1d5ffa7c6d081c5">camView</a> (<a class="el" href="structCamImage.html">CamImage</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">View an image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="29e7e764723f9f6e9c9222ddf8d5cd0d"></a><!-- doxytag: member="camellia.h::camVersion" ref="29e7e764723f9f6e9c9222ddf8d5cd0d" args="()" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#29e7e764723f9f6e9c9222ddf8d5cd0d">camVersion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the version of the library. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4043dc2be0ba8d7a173f280f5d007d61"></a><!-- doxytag: member="camellia.h::camDrawLine" ref="4043dc2be0ba8d7a173f280f5d007d61" args="(CamImage *image, int x1, int y1, int x2, int y2, int color)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#4043dc2be0ba8d7a173f280f5d007d61">camDrawLine</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int x1, int y1, int x2, int y2, int color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a line. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="58ab689dd945c0a44c13bfc1690567d9"></a><!-- doxytag: member="camellia.h::camAccumulateLine" ref="58ab689dd945c0a44c13bfc1690567d9" args="(CamImage *image, int x1, int y1, int x2, int y2, int acc)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#58ab689dd945c0a44c13bfc1690567d9">camAccumulateLine</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int x1, int y1, int x2, int y2, int acc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accumulate a line in a frame (very useful for Hough transforms). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cffc60a3e19b28ee96d0ae9e56eabc3d"></a><!-- doxytag: member="camellia.h::camDrawRectangle" ref="cffc60a3e19b28ee96d0ae9e56eabc3d" args="(CamImage *image, int x1, int y1, int x2, int y2, int color)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#cffc60a3e19b28ee96d0ae9e56eabc3d">camDrawRectangle</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int x1, int y1, int x2, int y2, int color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a rectangle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f988af691f73e1402f3cfd2d4d3520c1"></a><!-- doxytag: member="camellia.h::camDrawText16s" ref="f988af691f73e1402f3cfd2d4d3520c1" args="(CamImage *image, char *text, int x, int y, int cwidth, int cheight, int orientation, int color)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#f988af691f73e1402f3cfd2d4d3520c1">camDrawText16s</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, char *text, int x, int y, int cwidth, int cheight, int orientation, int color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw some text using 16 segments font (looks like an alarm clock...). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4adc874143a32e767aad5f3329fccb9c"></a><!-- doxytag: member="camellia.h::camDrawCircle" ref="4adc874143a32e767aad5f3329fccb9c" args="(CamImage *image, int x, int y, int r, int color)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#4adc874143a32e767aad5f3329fccb9c">camDrawCircle</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int x, int y, int r, int color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a circle. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46d433af3bb1ca759be272291622b130"></a><!-- doxytag: member="camellia.h::camDrawEllipse" ref="46d433af3bb1ca759be272291622b130" args="(CamImage *image, int x, int y, int rx, int ry, int color)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#46d433af3bb1ca759be272291622b130">camDrawEllipse</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int x, int y, int rx, int ry, int color)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw an ellipse. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#7e7bab9a4ef6bc165f2cf12290d014fc">camPlot</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int x, int y, int color, int kind)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plot.  <a href="#7e7bab9a4ef6bc165f2cf12290d014fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#1cb0a4ab978407d47b9117430d33c3ae">camFillColor</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int x, int y, int fillcolor, int tolerance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill a region with a color.  <a href="#1cb0a4ab978407d47b9117430d33c3ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f98ea6941be009a0b4c21858f1cc0698"></a><!-- doxytag: member="camellia.h::camLoadBitmapFont" ref="f98ea6941be009a0b4c21858f1cc0698" args="(CamBitmapFont *font, char *filename)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#f98ea6941be009a0b4c21858f1cc0698">camLoadBitmapFont</a> (<a class="el" href="structCamBitmapFont.html">CamBitmapFont</a> *font, char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a bitmap font. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8958f31168d1c65ddcb2a895b75c2045"></a><!-- doxytag: member="camellia.h::camFreeBitmapFont" ref="8958f31168d1c65ddcb2a895b75c2045" args="(CamBitmapFont *font)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#8958f31168d1c65ddcb2a895b75c2045">camFreeBitmapFont</a> (<a class="el" href="structCamBitmapFont.html">CamBitmapFont</a> *font)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate a bitmap font. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0dd59e044492e92d83b97fa895239398"></a><!-- doxytag: member="camellia.h::camDrawTextBitmap" ref="0dd59e044492e92d83b97fa895239398" args="(CamImage *image, char *text, int x, int y, CamBitmapFont *font)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#0dd59e044492e92d83b97fa895239398">camDrawTextBitmap</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, char *text, int x, int y, <a class="el" href="structCamBitmapFont.html">CamBitmapFont</a> *font)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw some text using a bitmap font. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#f26daf901d61d38ed4b5c2dfe82b9691">camRGB</a> (int r, int g, int b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">24 bits integer color representation. Stricly equivalent to the Windows RGB macro.  <a href="#f26daf901d61d38ed4b5c2dfe82b9691"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7527f24b971c50e84ee2438dd415c71f"></a><!-- doxytag: member="camellia.h::camRGBA" ref="7527f24b971c50e84ee2438dd415c71f" args="(int r, int g, int b, int a)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#7527f24b971c50e84ee2438dd415c71f">camRGBA</a> (int r, int g, int b, int a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">32 bits integer color representation, including an alpha channel <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b795d824e2bd8f384980b79729b974a6"></a><!-- doxytag: member="camellia.h::camLoadPGM" ref="b795d824e2bd8f384980b79729b974a6" args="(CamImage *image, char *fn)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#b795d824e2bd8f384980b79729b974a6">camLoadPGM</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, char *fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15f25150d0d3607c6e82d39ce713bfc3"></a><!-- doxytag: member="camellia.h::camSavePGM" ref="15f25150d0d3607c6e82d39ce713bfc3" args="(CamImage *image, char *filename)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#15f25150d0d3607c6e82d39ce713bfc3">camSavePGM</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a PGM image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="823fce2ce63e6c12b48c710d930d1e8b"></a><!-- doxytag: member="camellia.h::camSaveRawPGM" ref="823fce2ce63e6c12b48c710d930d1e8b" args="(CamImage *image, char *filename)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#823fce2ce63e6c12b48c710d930d1e8b">camSaveRawPGM</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a raw PGM image (8-bits only). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c7b9f5883f486f1af9971009347faf6f"></a><!-- doxytag: member="camellia.h::camLoadBMP" ref="c7b9f5883f486f1af9971009347faf6f" args="(CamImage *image, char *fn)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#c7b9f5883f486f1af9971009347faf6f">camLoadBMP</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, char *fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a BMP image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="06cd51a111de95af501a3e7425868f9c"></a><!-- doxytag: member="camellia.h::camSaveBMP" ref="06cd51a111de95af501a3e7425868f9c" args="(CamImage *image, char *filename)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#06cd51a111de95af501a3e7425868f9c">camSaveBMP</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a BMP image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9737d2773ffdc477ce487427567790d5"></a><!-- doxytag: member="camellia.h::camLoadConfig" ref="9737d2773ffdc477ce487427567790d5" args="(const char *filename, CamConfig *config)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camLoadConfig</b> (const char *filename, CamConfig *config)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32472645fe4958655937a0fdb2a363b2"></a><!-- doxytag: member="camellia.h::camConfigInt" ref="32472645fe4958655937a0fdb2a363b2" args="(const CamConfig *config, const char *entry)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camConfigInt</b> (const CamConfig *config, const char *entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3ce99fdc7664ca9aae4cae28c52cd567"></a><!-- doxytag: member="camellia.h::camConfigFloat" ref="3ce99fdc7664ca9aae4cae28c52cd567" args="(const CamConfig *config, const char *entry)" -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><b>camConfigFloat</b> (const CamConfig *config, const char *entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2065acc3c19a73160ff0bf88ec8aaca5"></a><!-- doxytag: member="camellia.h::camConfigString" ref="2065acc3c19a73160ff0bf88ec8aaca5" args="(const CamConfig *config, const char *entry)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>camConfigString</b> (const CamConfig *config, const char *entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b73e18eff2df4ab015ceca2be8c2bd7"></a><!-- doxytag: member="camellia.h::camCaptureInit" ref="5b73e18eff2df4ab015ceca2be8c2bd7" args="(int options)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><b>camCaptureInit</b> (int options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8657050942d914c575e4ea4d6e3db55a"></a><!-- doxytag: member="camellia.h::camCapture" ref="8657050942d914c575e4ea4d6e3db55a" args="(void *handle, CamImage *image)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camCapture</b> (void *handle, <a class="el" href="structCamImage.html">CamImage</a> *image)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0cd956887898a789d957e70b672d32c2"></a><!-- doxytag: member="camellia.h::camCaptureOver" ref="0cd956887898a789d957e70b672d32c2" args="(void *handle)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camCaptureOver</b> (void *handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd5488e303f8e030cca6dd592f987c89"></a><!-- doxytag: member="camellia.h::camError" ref="dd5488e303f8e030cca6dd592f987c89" args="(char *module, char *error)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#dd5488e303f8e030cca6dd592f987c89">camError</a> (char *module, char *error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error management function. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8faac59f784583aee8e0e07ad5b3262"></a><!-- doxytag: member="camellia.h::camSetErrorFunct" ref="e8faac59f784583aee8e0e07ad5b3262" args="(camErrorFunct funct)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>camSetErrorFunct</b> (camErrorFunct funct)</td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c4aec999467782a435e90a17bf04df0"></a><!-- doxytag: member="camellia.h::CAM_RGBA" ref="0c4aec999467782a435e90a17bf04df0" args="(r, g, b, a)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#0c4aec999467782a435e90a17bf04df0">CAM_RGBA</a>(r, g, b, a)&nbsp;&nbsp;&nbsp;((r)|((g)&lt;&lt;8)|((b)&lt;&lt;16)|((a)&lt;&lt;24))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">32 bits integer color representation, including an alpha channel. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba7f529322af216adbff44dd5dda429a"></a><!-- doxytag: member="camellia.h::CAM_RGB" ref="ba7f529322af216adbff44dd5dda429a" args="(r, g, b)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#ba7f529322af216adbff44dd5dda429a">CAM_RGB</a>(r, g, b)&nbsp;&nbsp;&nbsp;((r)|((g)&lt;&lt;8)|((b)&lt;&lt;16))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">24 bits integer color representation. Stricly equivalent to the Windows RGB macro. Please use this one in place of RGB for better portability of the code. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#893c77311bc86c4e0cd4145e9e4d73c5">camMonadicArithm</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamArithmParams.html">CamArithmParams</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the function that implements all the monadic arithmetic operators (i.e. operators with only one operand).  <a href="#893c77311bc86c4e0cd4145e9e4d73c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#92644056e097e0734e774001fbcdcacb">camDyadicArithm</a> (<a class="el" href="structCamImage.html">CamImage</a> *source1, <a class="el" href="structCamImage.html">CamImage</a> *source2, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamArithmParams.html">CamArithmParams</a> *params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the function that implements all the dyadic arithmetic operators (i.e. operators with two operands).  <a href="#92644056e097e0734e774001fbcdcacb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#a075aa7e1acffc34056c8ea2e0793c15">camAdd</a> (<a class="el" href="structCamImage.html">CamImage</a> *source1, <a class="el" href="structCamImage.html">CamImage</a> *source2, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Image addition.  <a href="#a075aa7e1acffc34056c8ea2e0793c15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#32b76b2d5b19d62ec552a8bb8ff2e469">camMul</a> (<a class="el" href="structCamImage.html">CamImage</a> *source1, <a class="el" href="structCamImage.html">CamImage</a> *source2, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Image multiplication.  <a href="#32b76b2d5b19d62ec552a8bb8ff2e469"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#ca659e68abd6449dfdd72070f55f3ef7">camSub</a> (<a class="el" href="structCamImage.html">CamImage</a> *source1, <a class="el" href="structCamImage.html">CamImage</a> *source2, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Image subtraction.  <a href="#ca659e68abd6449dfdd72070f55f3ef7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#3da02773030098aa2560d20c433508f1">camThreshold</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, int threshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple threshold function (wrapper for <a class="el" href="camellia_8h.html#893c77311bc86c4e0cd4145e9e4d73c5" title="This is the function that implements all the monadic arithmetic operators (i.e. operators...">camMonadicArithm()</a> function).  <a href="#3da02773030098aa2560d20c433508f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#a662752c18c3bef9387a1eeb2de12ac5">camThresholdInv</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, int threshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple threshold function (wrapper for <a class="el" href="camellia_8h.html#893c77311bc86c4e0cd4145e9e4d73c5" title="This is the function that implements all the monadic arithmetic operators (i.e. operators...">camMonadicArithm()</a> function).  <a href="#a662752c18c3bef9387a1eeb2de12ac5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f143e0650065dfaffe00db233efd3f9"></a><!-- doxytag: member="camellia.h::camAbs" ref="3f143e0650065dfaffe00db233efd3f9" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#3f143e0650065dfaffe00db233efd3f9">camAbs</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute absolute value of image (for signed images) (wrapper for <a class="el" href="camellia_8h.html#893c77311bc86c4e0cd4145e9e4d73c5" title="This is the function that implements all the monadic arithmetic operators (i.e. operators...">camMonadicArithm()</a> function). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1059dd4f90093463d612651ebe7b340a"></a><!-- doxytag: member="camellia.h::camApplyLUT" ref="1059dd4f90093463d612651ebe7b340a" args="(CamImage *source, CamImage *dest, CamTable *LUT)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#1059dd4f90093463d612651ebe7b340a">camApplyLUT</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamTable.html">CamTable</a> *LUT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a Look-Up-Table on image function. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#5fc50b255032118cd481cf644c9ea49a">camLabeling</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamLabelingResults.html">CamLabelingResults</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">4-connectedness labeling function  <a href="#5fc50b255032118cd481cf644c9ea49a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#2a3522307f11a548e4cb1f335924e348">camLabeling2ndScan</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, <a class="el" href="structCamLabelingResults.html">CamLabelingResults</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Second scan for pixel-based labeling. Obsolete.  <a href="#2a3522307f11a548e4cb1f335924e348"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#dc751b1d21a7292086532567b39d5075">camBlobAnalysis1stScan</a> (<a class="el" href="structCamImage.html">CamImage</a> *blobImage, <a class="el" href="structCamImage.html">CamImage</a> *original, <a class="el" href="structCamLabelingResults.html">CamLabelingResults</a> *info, <a class="el" href="structCamBlobs.html">CamBlobs</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blob analysis function.  <a href="#dc751b1d21a7292086532567b39d5075"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#4375c67533e4bf2d01d0a53453e366e3">camBlobAnalysisRefinement</a> (<a class="el" href="structCamImage.html">CamImage</a> *blobImage, <a class="el" href="structCamImage.html">CamImage</a> *original, <a class="el" href="structCamBlobs.html">CamBlobs</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Second pass, to get some more information if needed.  <a href="#4375c67533e4bf2d01d0a53453e366e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#4ba2c4e9781a3673450d209cc0b67aad">camSumHV</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, <a class="el" href="structCamTable.html">CamTable</a> *hsum, <a class="el" href="structCamTable.html">CamTable</a> *vsum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Horizontal and vertical summing function.  <a href="#4ba2c4e9781a3673450d209cc0b67aad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#b3bf851a2a4e3239812265c3500a3465">camSumV</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, <a class="el" href="structCamTable.html">CamTable</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vertical summing function.  <a href="#b3bf851a2a4e3239812265c3500a3465"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#e7d48717a112c84b2b75e67e012b9cfa">camSumH</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, <a class="el" href="structCamTable.html">CamTable</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Horizontal summing function.  <a href="#e7d48717a112c84b2b75e67e012b9cfa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25a8c3d19870e6593217af9734a4d8a5"></a><!-- doxytag: member="camellia.h::camSumOfPixels" ref="25a8c3d19870e6593217af9734a4d8a5" args="(CamImage *image)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#25a8c3d19870e6593217af9734a4d8a5">camSumOfPixels</a> (<a class="el" href="structCamImage.html">CamImage</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum of pixels in an image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#0d49d0d48bae1e33557913d5b46c2c56">camMeasures</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, <a class="el" href="structCamMeasuresResults.html">CamMeasuresResults</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measures in an image : min, max, average and sum.  <a href="#0d49d0d48bae1e33557913d5b46c2c56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#55f4073da0fd5b396807694f34351edd">camMeasureAverageDeviation</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int average)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Average deviation computation.  <a href="#55f4073da0fd5b396807694f34351edd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Morphomaths LLAs</div></td></tr>
<tr><td colspan="2"><div class="groupText">These functions share the same morpho maths kernel <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#52d51b9230e15d3f4de74a5d0a9c6c11">camMorphoMaths</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the function that can compute erosion AND dilation in one scan (with 5x5 neighborhood).  <a href="#52d51b9230e15d3f4de74a5d0a9c6c11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#66d45657c1f0d5c57ff29a6db5737124">camErode3x3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 neighborhood erosion  <a href="#66d45657c1f0d5c57ff29a6db5737124"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#509eb9626695b34a758cc646331d5738">camErode5x5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5x5 neighborhood erosion  <a href="#509eb9626695b34a758cc646331d5738"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#40c1bc1ac3471c2b2b9d80196ef7c84b">camErode7x7</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">7x7 neighborhood erosion  <a href="#40c1bc1ac3471c2b2b9d80196ef7c84b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#ea6d49b279e9f8b9a37ca76d76132dec">camDilate3x3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">3x3 neighborhood dilation  <a href="#ea6d49b279e9f8b9a37ca76d76132dec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#25292226167d1208b5f2a0201c993f76">camDilate5x5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">5x5 neighborhood dilation  <a href="#25292226167d1208b5f2a0201c993f76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#877f74ef21bc6137de91330bc8221d51">camDilate7x7</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *kernel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">7x7 neighborhood dilation  <a href="#877f74ef21bc6137de91330bc8221d51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#293efc2f56e0b03053570e365fc0186f">camMorphoGradientCircle5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Morphological gradient computation (Diameter-5 circle structural element).  <a href="#293efc2f56e0b03053570e365fc0186f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#17cbf594bed35eed1ad716bcfd586a2e">camErodeCircle5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erosion (Optimized for diameter-5 circle structural element).  <a href="#17cbf594bed35eed1ad716bcfd586a2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#290c44dc86b91ddfa7ed37d954e687d3">camDilateCircle5</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dilation (Optimized for diameter-5 circle structural element).  <a href="#290c44dc86b91ddfa7ed37d954e687d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#f2ea7f9675545d5679c241888c13981c">camMorphoGradientCircle7</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Morphological gradient computation (Diameter-7 circle structural element).  <a href="#f2ea7f9675545d5679c241888c13981c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#681f725ab242ecd8decf7c69fe84a941">camErodeCircle7</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erosion (Optimized for diameter-7 circle structural element).  <a href="#681f725ab242ecd8decf7c69fe84a941"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#804d77aabcd5f77d3a4dd5f0fabb97ad">camDilateCircle7</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dilation (Optimized for diameter-7 circle structural element).  <a href="#804d77aabcd5f77d3a4dd5f0fabb97ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#2a4c93e9b36955b34685629043ce4de1">camMorphoGradientSquare3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Morphological gradient computation (3x3 square structural element).  <a href="#2a4c93e9b36955b34685629043ce4de1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#944740494c1d9a5052d7976c1ca7037e">camErodeSquare3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erosion (3x3 square structural element).  <a href="#944740494c1d9a5052d7976c1ca7037e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#c91a921eddbe7e9650944dc637cd82ef">camDilateSquare3</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dilation (3x3 square structural element).  <a href="#c91a921eddbe7e9650944dc637cd82ef"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">RLE images processing functions and data structures</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#7abff958da31df68c1e2e51876303592">camRLEAllocate</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *rle, int max_runs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE Image allocation.  <a href="#7abff958da31df68c1e2e51876303592"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#2c150b160d28340ece465e8161eb8757">camRLEDeallocate</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *rle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE image deallocation.  <a href="#2c150b160d28340ece465e8161eb8757"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0a2fb1b231e97725a8cd46e91a489daa"></a><!-- doxytag: member="camellia.h::camRLEFree" ref="0a2fb1b231e97725a8cd46e91a489daa" args="(CamRLEImage *rle)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#0a2fb1b231e97725a8cd46e91a489daa">camRLEFree</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *rle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for <a class="el" href="camellia_8h.html#2c150b160d28340ece465e8161eb8757" title="RLE image deallocation.">camRLEDeallocate()</a> function. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#b2e398655ce514efabaf74a2caca3447">camRLEReallocate</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *rle, int new_max_runs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE image reallocation.  <a href="#b2e398655ce514efabaf74a2caca3447"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#f6c8ab5acec8857c8299ba9a9e63fffd">camRLEClone</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *source, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE image cloning.  <a href="#f6c8ab5acec8857c8299ba9a9e63fffd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#a699c24c3840fca04e838d731aea1b7a">camRLEEncode</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run-Length encoding.  <a href="#a699c24c3840fca04e838d731aea1b7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#36b4ca7ddca5c72859d5cb88a3875887">camRLEEncodeLUT</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *dest, <a class="el" href="structCamTable.html">CamTable</a> *LUT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run-Length encoding, with integrated LUT operations.  <a href="#36b4ca7ddca5c72859d5cb88a3875887"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#df671bd0479a0f1d78884878a7bdf3c3">camRLEEncodeThreshold</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *dest, int threshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run-Length encoding, with integrated thresholding.  <a href="#df671bd0479a0f1d78884878a7bdf3c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#2fab509f921ec4f4a8aef3ef93344347">camRLEEncodeThresholdInv</a> (<a class="el" href="structCamImage.html">CamImage</a> *src, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *dest, int threshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run-Length encoding, with integrated thresholding.  <a href="#2fab509f921ec4f4a8aef3ef93344347"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6185726ff215bf7211509cc7573f159"></a><!-- doxytag: member="camellia.h::camRLEEncodeColor" ref="b6185726ff215bf7211509cc7573f159" args="(CamImage *source, CamRLEImage *dest, CamTable *clusters)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camRLEEncodeColor</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *dest, <a class="el" href="structCamTable.html">CamTable</a> *clusters)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#348632f8fe184c8a0340d1adaf316e0d">camRLELabeling</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *src, <a class="el" href="structCamBlobs.html">CamBlobs</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE image labeling + blob analysis. 4-connectedness labeling.  <a href="#348632f8fe184c8a0340d1adaf316e0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#7bdba2a8e16e2f3bd55dc8250bbafd39">camRLEBlobAnalysis</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *src, <a class="el" href="structCamBlobs.html">CamBlobs</a> *results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The RLE Blob Analysis function.  <a href="#7bdba2a8e16e2f3bd55dc8250bbafd39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#117c49e467f08ecec1f4f48b8059d37a">camRLEApplyLUT</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *src, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *dest, <a class="el" href="structCamTable.html">CamTable</a> *LUT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The RLE "Apply a LUT" function.  <a href="#117c49e467f08ecec1f4f48b8059d37a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#ebccaa8cc9e341ef28bc1184db25ac58">camRLEDecode</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *src, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamTable.html">CamTable</a> *LUT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The RLE decoding function.  <a href="#ebccaa8cc9e341ef28bc1184db25ac58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#7b4e74dc430b35b0e7faf5243f705ffd">camRLEDecodeBlobs</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *src, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamTable.html">CamTable</a> *LUT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Another RLE decoding function, used to retrieve some specific blobs.  <a href="#7b4e74dc430b35b0e7faf5243f705ffd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#3916b4991abbef547603dc205381a251">camRLEInverse</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE image inversion.  <a href="#3916b4991abbef547603dc205381a251"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b18d8a0893fc962226c70f0fbe7d5276"></a><!-- doxytag: member="camellia.h::camRLEBlobSides" ref="b18d8a0893fc962226c70f0fbe7d5276" args="(CamBlobInfo *blob, int *left, int *top, int *right, int *bottom)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#b18d8a0893fc962226c70f0fbe7d5276">camRLEBlobSides</a> (<a class="el" href="structCamBlobInfo.html">CamBlobInfo</a> *blob, int *left, int *top, int *right, int *bottom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE blob sides reconstruction. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9b2aa4574f7ea43c845032725fa088d2"></a><!-- doxytag: member="camellia.h::camRLEBlobROIIntersect" ref="9b2aa4574f7ea43c845032725fa088d2" args="(CamBlobInfo *blob, CamROI *roi)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#9b2aa4574f7ea43c845032725fa088d2">camRLEBlobROIIntersect</a> (<a class="el" href="structCamBlobInfo.html">CamBlobInfo</a> *blob, <a class="el" href="structCamROI.html">CamROI</a> *roi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE blob intersection with a ROI. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4f8b9e5f17dfbbde1aa4718aa1d166d"></a><!-- doxytag: member="camellia.h::camRLEBlobMeasures" ref="a4f8b9e5f17dfbbde1aa4718aa1d166d" args="(CamBlobInfo *blob, CamImage *original)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#a4f8b9e5f17dfbbde1aa4718aa1d166d">camRLEBlobMeasures</a> (<a class="el" href="structCamBlobInfo.html">CamBlobInfo</a> *blob, <a class="el" href="structCamImage.html">CamImage</a> *original)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the average, min and max values. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#e68c93597753418b22d257ede896e4b9">camRLEErodeCross</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *image, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE image erosion (cross structural element).  <a href="#e68c93597753418b22d257ede896e4b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#b8204547f72749bab5e21100d07c5d8a">camRLEErode3x3</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *image, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE image erosion (3x3 square structural element).  <a href="#b8204547f72749bab5e21100d07c5d8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#741866f17383569eb9ef8549848d36bd">camRLEErode3x2</a> (<a class="el" href="structCamRLEImage.html">CamRLEImage</a> *image, <a class="el" href="structCamRLEImage.html">CamRLEImage</a> *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RLE image erosion (3x2 square structural element).  <a href="#741866f17383569eb9ef8549848d36bd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Hough functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#8d5f43e0d5e8d51ab70573bdc8f986e9">camHoughCircle</a> (<a class="el" href="structCamImage.html">CamImage</a> *image, int percent, int rmin, int rmax, int *xc, int *yc, int *rc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Circle Hough. Find a circle in a picture.  <a href="#8d5f43e0d5e8d51ab70573bdc8f986e9"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Color conversion functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36862e66ce65a8ea856b3cd1948bc9bf"></a><!-- doxytag: member="camellia.h::camYUV2RGB" ref="36862e66ce65a8ea856b3cd1948bc9bf" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#36862e66ce65a8ea856b3cd1948bc9bf">camYUV2RGB</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a YUV image to a RGB image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="13dd49f78d364201f6242b7ebe5defd6"></a><!-- doxytag: member="camellia.h::camRGB2YUV" ref="13dd49f78d364201f6242b7ebe5defd6" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#13dd49f78d364201f6242b7ebe5defd6">camRGB2YUV</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a RGB image to a YUV image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0bbdcdb9e8960a91e7519de8d02cea4"></a><!-- doxytag: member="camellia.h::camRGB2Y" ref="b0bbdcdb9e8960a91e7519de8d02cea4" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#b0bbdcdb9e8960a91e7519de8d02cea4">camRGB2Y</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a RGB image to a gray scale image. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b44d46b2cc8662b2f87a5e6207d7cc6"></a><!-- doxytag: member="camellia.h::camRGB2HLS" ref="5b44d46b2cc8662b2f87a5e6207d7cc6" args="(CamImage *source, CamImage *dest)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="camellia_8h.html#5b44d46b2cc8662b2f87a5e6207d7cc6">camRGB2HLS</a> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a RGB image to a HLS image. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Motion estimation functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0dc89c85b36921e2e81fc3fca9359b0"></a><!-- doxytag: member="camellia.h::camSAD8x8" ref="f0dc89c85b36921e2e81fc3fca9359b0" args="(CamImage *image1, CamImage *image2, int bleft, int btop, int dx, int dy)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camSAD8x8</b> (<a class="el" href="structCamImage.html">CamImage</a> *image1, <a class="el" href="structCamImage.html">CamImage</a> *image2, int bleft, int btop, int dx, int dy)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f73ea6f4a0a9dad7c5bf73720531107"></a><!-- doxytag: member="camellia.h::camSAD16x16" ref="8f73ea6f4a0a9dad7c5bf73720531107" args="(CamImage *image1, CamImage *image2, int bleft, int btop, int dx, int dy)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camSAD16x16</b> (<a class="el" href="structCamImage.html">CamImage</a> *image1, <a class="el" href="structCamImage.html">CamImage</a> *image2, int bleft, int btop, int dx, int dy)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="08ea1d0f7fa18b3b32ae0a27fcd2aee7"></a><!-- doxytag: member="camellia.h::camMotionEstimation3DRSInit" ref="08ea1d0f7fa18b3b32ae0a27fcd2aee7" args="(CamMotionEstimation3DRSParams *params, int seed, int lsearch, int rsearch, int bs, int scans, int candidates, int test0)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camMotionEstimation3DRSInit</b> (CamMotionEstimation3DRSParams *params, int seed, int lsearch, int rsearch, int bs, int scans, int candidates, int test0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bd5b583b42b83765ed268cc179698505"></a><!-- doxytag: member="camellia.h::camMotionEstimation3DRS" ref="bd5b583b42b83765ed268cc179698505" args="(CamImage *current, CamImage *previous, CamMotionEstimation3DRSParams *params, CamMotionEstimation3DRSResults *results)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camMotionEstimation3DRS</b> (<a class="el" href="structCamImage.html">CamImage</a> *current, <a class="el" href="structCamImage.html">CamImage</a> *previous, CamMotionEstimation3DRSParams *params, CamMotionEstimation3DRSResults *results)</td></tr>

<tr><td colspan="2"><div class="groupHeader">3D Projection/Retroprojection functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c35c47af053c17b49366240a6bb2e97c"></a><!-- doxytag: member="camellia.h::camProject" ref="c35c47af053c17b49366240a6bb2e97c" args="(const double extr[4][4], const double fc[2], const double cc[2], double x, double y, double z, int *xp, int *yp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>camProject</b> (const double extr[4][4], const double fc[2], const double cc[2], double x, double y, double z, int *xp, int *yp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7254e3f10a36cfb847f00c04916102a9"></a><!-- doxytag: member="camellia.h::camBackproject" ref="7254e3f10a36cfb847f00c04916102a9" args="(const double extr[4][4], const double fc[2], const double cc[2], int xp, int yp, double z, double *x, double *y)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>camBackproject</b> (const double extr[4][4], const double fc[2], const double cc[2], int xp, int yp, double z, double *x, double *y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d34c1df59d299145a7654a993feec2d0"></a><!-- doxytag: member="camellia.h::camUndistort" ref="d34c1df59d299145a7654a993feec2d0" args="(CamImage *source, CamImage *dest, const float *intrinsic_matrix, const float *dist_coeffs)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camUndistort</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, const float *intrinsic_matrix, const float *dist_coeffs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d15dc9960618653fd7cd6406d577343"></a><!-- doxytag: member="camellia.h::camUndistortFixed" ref="6d15dc9960618653fd7cd6406d577343" args="(CamImage *source, CamImage *dest, const CAM_FIXED_POINT *intrinsic_matrix, const CAM_FIXED_POINT *dist_coeffs)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camUndistortFixed</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, const CAM_FIXED_POINT *intrinsic_matrix, const CAM_FIXED_POINT *dist_coeffs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3070630ee71ff79b94b514c615505ead"></a><!-- doxytag: member="camellia.h::camUndistortBuildLUT" ref="3070630ee71ff79b94b514c615505ead" args="(CamImage *source, const float *intrinsic_matrix, const float *dist_coeffs, CamImage *LUTX, CamImage *LUTY)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camUndistortBuildLUT</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, const float *intrinsic_matrix, const float *dist_coeffs, <a class="el" href="structCamImage.html">CamImage</a> *LUTX, <a class="el" href="structCamImage.html">CamImage</a> *LUTY)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d316b842e01b1badea69f44c029fce84"></a><!-- doxytag: member="camellia.h::camUndistortLUT" ref="d316b842e01b1badea69f44c029fce84" args="(CamImage *source, CamImage *dest, CamImage *LUTX, CamImage *LUTY)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>camUndistortLUT</b> (<a class="el" href="structCamImage.html">CamImage</a> *source, <a class="el" href="structCamImage.html">CamImage</a> *dest, <a class="el" href="structCamImage.html">CamImage</a> *LUTX, <a class="el" href="structCamImage.html">CamImage</a> *LUTY)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Camellia Image Processing Library header file. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Bruno STEUX (Mines Paris / ParisTech)</dd></dl>
Camellia Image Processing Library<p>
The Camellia Image Processing Library is an open source low-level image processing library. As it uses the IplImage structure to describe images, it is a good replacement to the IPL (Intel) library and a good complement to the OpenCV library. It includes a lot of functions for image processing (filtering, morphological mathematics, labeling, warping, loading/saving images, etc.), some of them being highly optimized; It is also cross-platform and robust. It is doxygen-documented and examples of use are provided.<p>
This software library is an outcome of the Camellia european project (IST-2001-34410). It was developped by the Ecole des Mines de Paris (ENSMP), in coordination with the other partners of the project.<p>
==========================================================================<p>
Copyright (c) 2002-2007, Ecole des Mines de Paris - Centre de Robotique All rights reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Ecole des Mines de Paris nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<p>
========================================================================== <hr><h2>Function Documentation</h2>
<a class="anchor" name="a075aa7e1acffc34056c8ea2e0793c15"></a><!-- doxytag: member="camellia.h::camAdd" ref="a075aa7e1acffc34056c8ea2e0793c15" args="(CamImage *source1, CamImage *source2, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camAdd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Image addition. 
<p>
Simple wrapper for <a class="el" href="camellia_8h.html#92644056e097e0734e774001fbcdcacb" title="This is the function that implements all the dyadic arithmetic operators (i.e. operators...">camDyadicArithm()</a> 
</div>
</div><p>
<a class="anchor" name="29df19c4f072e54051e16dbae679d8ec"></a><!-- doxytag: member="camellia.h::camAlphaComposite" ref="29df19c4f072e54051e16dbae679d8ec" args="(CamImage *source1, CamImage *source2, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camAlphaComposite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alpha channel compositing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source1</em>&nbsp;</td><td>must be a RGB image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source2</em>&nbsp;</td><td>must be a RGBA image (with an alpha channel) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination image </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dc751b1d21a7292086532567b39d5075"></a><!-- doxytag: member="camellia.h::camBlobAnalysis1stScan" ref="dc751b1d21a7292086532567b39d5075" args="(CamImage *blobImage, CamImage *original, CamLabelingResults *info, CamBlobs *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camBlobAnalysis1stScan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>blobImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamLabelingResults.html">CamLabelingResults</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamBlobs.html">CamBlobs</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Blob analysis function. 
<p>
Computes the most important blob information : <code>top</code>, <code>left</code>, <code>width</code>, <code>height</code>, <code>cx</code>, <code>cy</code>, and <code>surface</code>. <code>average</code>, <code>min</code> and <code>max</code> are computed only if a pointer on the original image is provided (slower).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blobImage</em>&nbsp;</td><td>The result of a previous labeling operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>The original <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> that was labelled previously. Can bet set to NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The <a class="el" href="structCamLabelingResults.html" title="Data structure containing the result of pixel-based labeling.">CamLabelingResults</a> structure provided by the former call to <a class="el" href="camellia_8h.html#5fc50b255032118cd481cf644c9ea49a" title="4-connectedness labeling function">camLabeling()</a>.(in data) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The <a class="el" href="structCamBlobs.html" title="The result of any blob analysis. Essentially an array of CamBlobInfo.">CamBlobs</a> structure that is filled with the collected blob information.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs, especially if the number of blobs is too high.(more than the <code>CAM_LABEL_MAX_BLOBS</code> constant)</dd></dl>
In-place processing (<code>blobImage</code> will be affected). 
</div>
</div><p>
<a class="anchor" name="4375c67533e4bf2d01d0a53453e366e3"></a><!-- doxytag: member="camellia.h::camBlobAnalysisRefinement" ref="4375c67533e4bf2d01d0a53453e366e3" args="(CamImage *blobImage, CamImage *original, CamBlobs *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camBlobAnalysisRefinement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>blobImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamBlobs.html">CamBlobs</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Second pass, to get some more information if needed. 
<p>
Computes the <code>average</code>, <code>min</code> and <code>max</code> blob information, if it was not computed before.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blobImage</em>&nbsp;</td><td>The result of a previous labeling operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>The original CamImage.that was labelled previously. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The <a class="el" href="structCamBlobs.html" title="The result of any blob analysis. Essentially an array of CamBlobInfo.">CamBlobs</a> structure that is filled with the collected blob information.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a6430576f1b718bc261009289418d9d"></a><!-- doxytag: member="camellia.h::camClone" ref="1a6430576f1b718bc261009289418d9d" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camClone           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple cloning function. 
<p>
This function allocates the memory for the dest image. dest actual content is not considered by this function. Beware not to have allocated an image in dest before, otherwise this will result in a memory leak. 
</div>
</div><p>
<a class="anchor" name="7b021e7ba78039afe11819d1bc9e906b"></a><!-- doxytag: member="camellia.h::camCopy" ref="7b021e7ba78039afe11819d1bc9e906b" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camCopy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy function, without any color space conversion, but able to deal with planar/pixel oriented conversion, ROIs and even masking. 
<p>
Supports grey scale to color conversion, as well as RGB to RGBA, and RGBA to RGB copying (adding and removing alpha channel)<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea6d49b279e9f8b9a37ca76d76132dec"></a><!-- doxytag: member="camellia.h::camDilate3x3" ref="ea6d49b279e9f8b9a37ca76d76132dec" args="(CamImage *source, CamImage *dest, CamMorphoMathsKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camDilate3x3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 neighborhood dilation 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamMorphoMathsKernel.html" title="This is the parameter structure for the morpho maths kernel.">CamMorphoMathsKernel</a> structure, defining the structural element to use. Only the DilationStructElt member is used by this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="25292226167d1208b5f2a0201c993f76"></a><!-- doxytag: member="camellia.h::camDilate5x5" ref="25292226167d1208b5f2a0201c993f76" args="(CamImage *source, CamImage *dest, CamMorphoMathsKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camDilate5x5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
5x5 neighborhood dilation 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamMorphoMathsKernel.html" title="This is the parameter structure for the morpho maths kernel.">CamMorphoMathsKernel</a> structure, defining the structural element to use. Only the DilationStructElt member is used by this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="877f74ef21bc6137de91330bc8221d51"></a><!-- doxytag: member="camellia.h::camDilate7x7" ref="877f74ef21bc6137de91330bc8221d51" args="(CamImage *source, CamImage *dest, CamMorphoMathsKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camDilate7x7           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
7x7 neighborhood dilation 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamMorphoMathsKernel.html" title="This is the parameter structure for the morpho maths kernel.">CamMorphoMathsKernel</a> structure, defining the structural element to use. Only the DilationStructElt member is used by this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="290c44dc86b91ddfa7ed37d954e687d3"></a><!-- doxytag: member="camellia.h::camDilateCircle5" ref="290c44dc86b91ddfa7ed37d954e687d3" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camDilateCircle5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dilation (Optimized for diameter-5 circle structural element). 
<p>
Computes the dilated image of a source image, using a circular structural element of diameter 5. Highly optimized code.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="804d77aabcd5f77d3a4dd5f0fabb97ad"></a><!-- doxytag: member="camellia.h::camDilateCircle7" ref="804d77aabcd5f77d3a4dd5f0fabb97ad" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camDilateCircle7           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dilation (Optimized for diameter-7 circle structural element). 
<p>
Computes the dilated image of a source image, using a circular structural element of diameter 7. Highly optimized code.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="c91a921eddbe7e9650944dc637cd82ef"></a><!-- doxytag: member="camellia.h::camDilateSquare3" ref="c91a921eddbe7e9650944dc637cd82ef" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camDilateSquare3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dilation (3x3 square structural element). 
<p>
Computes the dilated image of a source image, using a classical 3x3 square structural element. Highly optimized code.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="92644056e097e0734e774001fbcdcacb"></a><!-- doxytag: member="camellia.h::camDyadicArithm" ref="92644056e097e0734e774001fbcdcacb" args="(CamImage *source1, CamImage *source2, CamImage *dest, CamArithmParams *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camDyadicArithm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamArithmParams.html">CamArithmParams</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the function that implements all the dyadic arithmetic operators (i.e. operators with two operands). 
<p>
This function can be used to compute the sum of two images (<code>CAM_ARITHM_ADD</code>), to substract two images (<code>CAM_ARITHM_SUB</code>), to compute the absolute difference between two images (<code>CAM_ARITHM_ABSDIFF</code>), to compute the weighted sum of two images (<code>CAM_ARITHM_WEIGHTED_SUM</code>), etc. (see below)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source1</em>&nbsp;</td><td>The first source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Any source image can be either grey-level or binary, depending on the operation to apply.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source2</em>&nbsp;</td><td>The second source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Any source image can be either grey-level or binary, depending on the operation to apply.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. The destination image can be either a grey-level image or a binary image, but source1, source2 and dest must be of the same kind.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamArithmParams.html" title="This is the parameter structure for the arithmetic computation kernel.">CamArithmParams</a> structure, defining all the parameters of the function to apply to the source images.</td></tr>
  </table>
</dl>
Here are the details on the operations and parameters to set in the <a class="el" href="structCamArithmParams.html" title="This is the parameter structure for the arithmetic computation kernel.">CamArithmParams</a> structure :<ul>
<li><code>CAM_ARITHM_ADD</code> : Addition of images, with saturation. <em>pdest=psource1+psource2; if (pdest&lt;0) then pdest=0; if (pdest&gt;valmax) then pdest=valmax</em>.</li><li><code>CAM_ARITHM_SUB</code> : Substraction of images, with saturation. <em>pdest=psource1-psource2; if (pdest&lt;valmin) then pdest=valmin; if (pdest&gt;valmax) then pdest=valmax</em>.</li><li><code>CAM_ARITHM_MUL</code> : Multiplication of images, with saturation. <em>pdest=(psource1*psource2)&gt;&gt;c1; if (pdest&lt;valmin) then pdest=valmin; if (pdest&gt;valmax) then pdest=valmax</em>.</li><li><code>CAM_ARITHM_ABSDIFF</code> : Absolute difference, with saturation. <em>pdest=abs(psource1-psource2)</em>.</li><li><code>CAM_ARITHM_WEIGHTED_SUM</code> : Weighted sum. <em>pdest=(c1*psource1+c2*psource2)&gt;&gt;c3</em>.</li><li><code>CAM_ARITHM_INF</code> : Inf. <em>pdest=inf(psource1,psource2)</em>.</li><li><code>CAM_ARITHM_SUP</code> : Sup. <em>pdest=sup(psource1,psource2)</em>.</li><li><code>CAM_ARITHM_COMP_INF</code> : Comparison. <em>if (psource1&lt;psource2) pdest=c1 else pdest=c2</em>.</li><li><code>CAM_ARITHM_COMP_EQUAL</code> : Equality test. <em>if (psource1=psource2) pdest=c1 else pdest=c2</em>.</li><li><code>CAM_ARITHM_COMP_SUP</code> : Comparison. <em>if (psource1&gt;psource2) pdest=c1 else pdest=c2</em>.</li><li><code>CAM_ARITHM_AND</code> : <em>pdest=psource1 &amp; psource2</em> (arithmetic boolean "and" operator)</li><li><code>CAM_ARITHM_OR</code> : <em>pdest=psource1 | psource2</em> (arithmetic boolean "or" operator)</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. An accumulator of all results pixel values otherwise.</dd></dl>
Note that this kernel supports in-place processing (i.e. dest can be the same as one of the sources).<p>
Note also that this kernel supports signed images, and thus can produce signed results (see the member depth in <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> structure). 
</div>
</div><p>
<a class="anchor" name="66d45657c1f0d5c57ff29a6db5737124"></a><!-- doxytag: member="camellia.h::camErode3x3" ref="66d45657c1f0d5c57ff29a6db5737124" args="(CamImage *source, CamImage *dest, CamMorphoMathsKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camErode3x3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 neighborhood erosion 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamMorphoMathsKernel.html" title="This is the parameter structure for the morpho maths kernel.">CamMorphoMathsKernel</a> structure, defining the structural element to use. Only the ErosionStructElt member is used by this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="509eb9626695b34a758cc646331d5738"></a><!-- doxytag: member="camellia.h::camErode5x5" ref="509eb9626695b34a758cc646331d5738" args="(CamImage *source, CamImage *dest, CamMorphoMathsKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camErode5x5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
5x5 neighborhood erosion 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamMorphoMathsKernel.html" title="This is the parameter structure for the morpho maths kernel.">CamMorphoMathsKernel</a> structure, defining the structural element to use. Only the ErosionStructElt member is used by this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="40c1bc1ac3471c2b2b9d80196ef7c84b"></a><!-- doxytag: member="camellia.h::camErode7x7" ref="40c1bc1ac3471c2b2b9d80196ef7c84b" args="(CamImage *source, CamImage *dest, CamMorphoMathsKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camErode7x7           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
7x7 neighborhood erosion 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamMorphoMathsKernel.html" title="This is the parameter structure for the morpho maths kernel.">CamMorphoMathsKernel</a> structure, defining the structural element to use. Only the ErosionStructElt member is used by this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="17cbf594bed35eed1ad716bcfd586a2e"></a><!-- doxytag: member="camellia.h::camErodeCircle5" ref="17cbf594bed35eed1ad716bcfd586a2e" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camErodeCircle5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erosion (Optimized for diameter-5 circle structural element). 
<p>
Computes the eroded image of a source image, using a circular structural element of diameter 5. Highly optimized code.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="681f725ab242ecd8decf7c69fe84a941"></a><!-- doxytag: member="camellia.h::camErodeCircle7" ref="681f725ab242ecd8decf7c69fe84a941" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camErodeCircle7           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erosion (Optimized for diameter-7 circle structural element). 
<p>
Computes the eroded image of a source image, using a circular structural element of diameter 7. Highly optimized code.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="944740494c1d9a5052d7976c1ca7037e"></a><!-- doxytag: member="camellia.h::camErodeSquare3" ref="944740494c1d9a5052d7976c1ca7037e" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camErodeSquare3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erosion (3x3 square structural element). 
<p>
Computes the eroded image of a source image, using a classical 3x3 square structural element. Highly optimized code.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="1cb0a4ab978407d47b9117430d33c3ae"></a><!-- doxytag: member="camellia.h::camFillColor" ref="1cb0a4ab978407d47b9117430d33c3ae" args="(CamImage *image, int x, int y, int fillcolor, int tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camFillColor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fillcolor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tolerance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill a region with a color. 
<p>
Try to fill the image with pixels as much possible pixels with the same color as the original pixel color in (x,y)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>horizontal coordinate where to start the filling </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>vertical coordinate where to start the filling </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fillcolor</em>&nbsp;</td><td>filling color (use CAM_RGB or CAM_RGBA macros to set this color) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tolerance</em>&nbsp;</td><td>this sets where the filling should stop. The reference is the color of the original pixel color in (x,y), and all the pixels nearby that are within the tolerance parameters get filled. If tolerance is set to -1, the filling stops with pixels having the same color as the filling color (this mode is very useful for filling circles, rectangles, etc.)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of colored pixels (at least 1 is function succeeds) </dd></dl>

</div>
</div><p>
<a class="anchor" name="099ac7ec4a0693a86314fb3eaabaf017"></a><!-- doxytag: member="camellia.h::camFixedFilter" ref="099ac7ec4a0693a86314fb3eaabaf017" args="(CamImage *source, CamImage *dest, int filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camFixedFilter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Linear convolution with a predefined kernel. 
<p>
The function <a class="el" href="camellia_8h.html#099ac7ec4a0693a86314fb3eaabaf017" title="Linear convolution with a predefined kernel.">camFixedFilter()</a> is used to convolve the input image with a predefined filter kernel specified in argument.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filter</em>&nbsp;</td><td>Constant defining the kernel to be used. The filter kernel can be one of the following :<ul>
<li><code>CAM_SOBEL_H</code> performs a horizontal edges detection (3x3 sobel)</li><li><code>CAM_SOBEL_V</code> performs a vertical edges detection (3x3 sobel)</li><li><code>CAM_GAUSSIAN_3x3</code> performs a gaussian filtering</li><li><code>CAM_GAUSSIAN_5x5</code> performs a gaussian filtering</li><li><code>CAM_GAUSSIAN_7x7</code> performs a gaussian filtering</li><li><code>CAM_SCHARR_H</code> performs a horizontal edges detection (3x3 scharr filter. Better preserves gradient direction)</li><li><code>CAM_SCHARR_V</code> performs a vertical edges detection (3x3 scharr filter. Better preserves gradient direction)</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the function succeeds. 0 otherwise.</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="43d708768b49c7fd7d70395682df50fd"></a><!-- doxytag: member="camellia.h::camHarris" ref="43d708768b49c7fd7d70395682df50fd" args="(CamImage *source, CamKeypoints *points, int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camHarris           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamKeypoints.html">CamKeypoints</a> *&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Harris corner detector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>Harris' corner detection parameter (default value is 41, matching k=0.04 in Harris' article) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="24e77c449137eb273e6da49d84ad114a"></a><!-- doxytag: member="camellia.h::camHierarchicalWatershed" ref="24e77c449137eb273e6da49d84ad114a" args="(CamImage *source, CamImage *dest, CamTableOfBasins *tob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camHierarchicalWatershed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTableOfBasins.html">CamTableOfBasins</a> *&nbsp;</td>
          <td class="paramname"> <em>tob</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
2D Hierarchical watershed computation 
<p>
Retrieves all the basins (regional segmentation)<p>
Watersheding computes a hierarchichal segmentation of an image. Watersheding operation is a very smart way to analyze the results of a gradient image.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> for which to compute the watershed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A 16-bits deep <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> where the results of the watersheding operation are stored. The index of the basin is given by the pixel value minus 1 (so starting at 1). Border pixels are set to -32768. <code>dest</code> must be allocated by the caller, and must have the same size as the <code>source</code> image. It must also be a signed 16 bits deep image (<code>CAM_DEPTH_16S</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tob</em>&nbsp;</td><td>The table of basins, containing their dynamics, their surface and their minimum value. This table is allocated by the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6d60c91f0e41c7f367b97870913c26b"></a><!-- doxytag: member="camellia.h::camHierarchicalWatershedContours" ref="d6d60c91f0e41c7f367b97870913c26b" args="(CamImage *source, CamImage *dest, CamTableOfBasins *tob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camHierarchicalWatershedContours           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTableOfBasins.html">CamTableOfBasins</a> *&nbsp;</td>
          <td class="paramname"> <em>tob</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
2D Hierarchical watershed computation (with watershed/contours markers) 
<p>
Retrieves all the watershed points, along with all the basins (regional segmentation)<p>
Watersheding computes a hierarchichal segmentation of an image. Watersheding operation is a very smart way to analyze the results of a gradient image.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> for which to compute the watershed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>A 16-bits deep <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> where the results of the watersheding operation are stored. A negative pixel value indicates a watershed point. A positive indicates that this pixel belongs to a basin. The index of the basin is given by the pixel value minus 1. Border pixels are set to -32768. <code>dest</code> must be allocated by the caller, and must have the same size as the <code>source</code> image. It must also be a signed 16 bits deep image (<code>CAM_DEPTH_16S</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tob</em>&nbsp;</td><td>The table of basins, containing their dynamics, their surface and their minimum value. This table is allocated by the function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd8315716d2699af0a2879ceee3f31ad"></a><!-- doxytag: member="camellia.h::camHierarchicalWatershedRegions" ref="cd8315716d2699af0a2879ceee3f31ad" args="(CamImage *watershed, CamTableOfBasins *tob)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camHierarchicalWatershedRegions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>watershed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTableOfBasins.html">CamTableOfBasins</a> *&nbsp;</td>
          <td class="paramname"> <em>tob</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves regions from a watershed image. 
<p>
Retrieves all the regions of basins with surface different from 0. The user can set the surface of a basin in the table of basins to deselect it. Thus, the user can remove from the watershed image all the basins with low dynamics, and the pixels of this basin will be affected to a flooding basin.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs </dd></dl>

</div>
</div><p>
<a class="anchor" name="2c8d0d19b76ab2b70bdb0863d265bc26"></a><!-- doxytag: member="camellia.h::camHistogram" ref="2c8d0d19b76ab2b70bdb0863d265bc26" args="(CamImage *image, CamTable *histo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camHistogram           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>histo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The classical image histogramming. 
<p>
Counts the number of occurence of each pixel value, on one channel only (grey-level image), for images up to 12-bits deep. It supports signed images by centering the histogram around the 0 value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to analyze. One channel only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>histo</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamTable.html" title="Pixel table (LUT (Look-Up Table) and histogram) structure.">CamTable</a> (array of integers) that will contain the results of histogramming. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. Accumulated values of scanned pixels otherwise.</dd></dl>
camHistogram supports masking and ROIs. 
</div>
</div><p>
<a class="anchor" name="de060106e377a48e599e782eb0331e81"></a><!-- doxytag: member="camellia.h::camHistogram2Channels" ref="de060106e377a48e599e782eb0331e81" args="(CamImage *image, int ch1, int ch2, CamImage *result, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camHistogram2Channels           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ch2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two channels histogram computation. 
<p>
The result of this operation is 2D, and thus is stored in an image.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> for which to compute the histogram </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch1</em>&nbsp;</td><td>The first channel number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch2</em>&nbsp;</td><td>The second channel number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> containing the results of histogramming. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Subsampling factor. size=1 results in a 256x256 picture, size=2 results in a 128x128 picture, etc. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c0e2148995a8b6f897c30bfa8687dc07"></a><!-- doxytag: member="camellia.h::camHistogramEqualization" ref="c0e2148995a8b6f897c30bfa8687dc07" args="(CamImage *src, CamImage *dest, CamTable *src_histo, int option, CamImage *work)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camHistogramEqualization           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>src_histo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>work</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Histogram Equalization. 
<p>
Performs a histogram equalization, with no holes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to equalize. One channel only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The resulting equalized image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_histo</em>&nbsp;</td><td>The histogram of the source image, obtained by a previous call to <a class="el" href="camellia_8h.html#2c8d0d19b76ab2b70bdb0863d265bc26" title="The classical image histogramming.">camHistogram()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td><code>CAM_EQUAL_FAST</code> or <code>CAM_EQUAL_PERFECT</code> (default) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>work</em>&nbsp;</td><td>A <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> used for internal computation. If set to NULL, allocation and deallocation will be done internally. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs.</dd></dl>
camHistogramEqualization supports in-place operation, masking and ROIs. 
</div>
</div><p>
<a class="anchor" name="8d5f43e0d5e8d51ab70573bdc8f986e9"></a><!-- doxytag: member="camellia.h::camHoughCircle" ref="8d5f43e0d5e8d51ab70573bdc8f986e9" args="(CamImage *image, int percent, int rmin, int rmax, int *xc, int *yc, int *rc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camHoughCircle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>yc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>rc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Circle Hough. Find a circle in a picture. 
<p>
Find a circle in the input picture. Returns the circle with the bigger hough accumulation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>percent</em>&nbsp;</td><td>The percentage of pixels to consider (from the gradient image). Directly proportionnal to the speed of exection. Typically 10. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rmin</em>&nbsp;</td><td>The minimum radius to look for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rmax</em>&nbsp;</td><td>The maximum radius to look for. This determines the size of the (x,y,r) Hough cube </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xc</em>&nbsp;</td><td>A pointer to the circle center (return value) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yc</em>&nbsp;</td><td>A pointer to the circle center (return value) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rc</em>&nbsp;</td><td>A pointer to the circle radius (return value)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The confidence in the circle found (hough accumulator) </dd></dl>

</div>
</div><p>
<a class="anchor" name="1dddcefcb50d0e498810bfc075cd6533"></a><!-- doxytag: member="camellia.h::camIntersectionSegments" ref="1dddcefcb50d0e498810bfc075cd6533" args="(CamPoint p[4], CamPoint *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camIntersectionSegments           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamPoint.html">CamPoint</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamPoint.html">CamPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple helper function, used by <a class="el" href="camellia_8h.html#ad957d473fde58077a501728e5aa8f13" title="Backward warping function.">camWarping()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>An array defining the segments to intersect (AB and CD). These points must be provided in 16-bits fixed-point arithmetic form (1 is (1&lt;&lt;16)). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>The intersection point. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the segments are parallel. 1 otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="5fc50b255032118cd481cf644c9ea49a"></a><!-- doxytag: member="camellia.h::camLabeling" ref="5fc50b255032118cd481cf644c9ea49a" args="(CamImage *source, CamImage *dest, CamLabelingResults *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camLabeling           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamLabelingResults.html">CamLabelingResults</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
4-connectedness labeling function 
<p>
Computes the labeled image of a source image, i.e. finds the connected pixels (using 4-connectedness)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>..Must be 16-bits deep (its the label result image) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The <a class="el" href="structCamLabelingResults.html" title="Data structure containing the result of pixel-based labeling.">CamLabelingResults</a> containing the label equivalence table, to provide to a blob analysis function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs</dd></dl>
Note that this function is rather obsolete. This pixel-based labeling algorithm is outdated compared to RLE-based labeling.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="camellia_8h.html#348632f8fe184c8a0340d1adaf316e0d" title="RLE image labeling + blob analysis. 4-connectedness labeling.">camRLELabeling</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a3522307f11a548e4cb1f335924e348"></a><!-- doxytag: member="camellia.h::camLabeling2ndScan" ref="2a3522307f11a548e4cb1f335924e348" args="(CamImage *image, CamLabelingResults *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camLabeling2ndScan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamLabelingResults.html">CamLabelingResults</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Second scan for pixel-based labeling. Obsolete. 
<p>
This algorithm is useless. Presented here for better understanding purpose only. Indeed, Blob analysis first scan (<a class="el" href="camellia_8h.html#dc751b1d21a7292086532567b39d5075" title="Blob analysis function.">camBlobAnalysis1stScan()</a>) integrates this second scan. In-place processing only. 
</div>
</div><p>
<a class="anchor" name="de3c164ac56119fc763e7b3060cba706"></a><!-- doxytag: member="camellia.h::camLinearFilter3x3" ref="de3c164ac56119fc763e7b3060cba706" args="(CamImage *source, CamImage *dest, CamLinearFilterKernel *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camLinearFilter3x3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Linear Filtering function 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamLinearFilterKernel.html" title="The parameters structure for linear filtering.">CamLinearFilterKernel</a> structure, providing the linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="5dca8ce13c5257c51f680383ede892bd"></a><!-- doxytag: member="camellia.h::camLinearFilter5x5" ref="5dca8ce13c5257c51f680383ede892bd" args="(CamImage *source, CamImage *dest, CamLinearFilterKernel *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camLinearFilter5x5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
5x5 Linear Filtering function 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamLinearFilterKernel.html" title="The parameters structure for linear filtering.">CamLinearFilterKernel</a> structure, providing the linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="2dd8fc9c63273b19eafe861814e207a3"></a><!-- doxytag: member="camellia.h::camLinearFilterAbs3x3" ref="2dd8fc9c63273b19eafe861814e207a3" args="(CamImage *source, CamImage *dest, CamLinearFilterKernel *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camLinearFilterAbs3x3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Linear Filtering function (absolute) 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamLinearFilterKernel.html" title="The parameters structure for linear filtering.">CamLinearFilterKernel</a> structure, providing the linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="786ba4a350d731400324e2d98a1194ff"></a><!-- doxytag: member="camellia.h::camLinearFilterAbs5x5" ref="786ba4a350d731400324e2d98a1194ff" args="(CamImage *source, CamImage *dest, CamLinearFilterKernel *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camLinearFilterAbs5x5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamLinearFilterKernel.html">CamLinearFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
5x5 Linear Filtering function (absolute) 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamLinearFilterKernel.html" title="The parameters structure for linear filtering.">CamLinearFilterKernel</a> structure, providing the linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="55f4073da0fd5b396807694f34351edd"></a><!-- doxytag: member="camellia.h::camMeasureAverageDeviation" ref="55f4073da0fd5b396807694f34351edd" args="(CamImage *image, int average)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float camMeasureAverageDeviation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>average</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Average deviation computation. 
<p>
This makes the second scan required for average deviation estimation. Uses the average field in <a class="el" href="structCamMeasuresResults.html" title="The structure containing the result of measuring.">CamMeasuresResults</a> structure, so <a class="el" href="camellia_8h.html#0d49d0d48bae1e33557913d5b46c2c56" title="Measures in an image : min, max, average and sum.">camMeasures()</a> must have been called prior to this function (to do the 1st scan).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process (or its ROI) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>average</em>&nbsp;</td><td>A former measure of average. If 0 or a negative number is provided, the average will be computed </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d49d0d48bae1e33557913d5b46c2c56"></a><!-- doxytag: member="camellia.h::camMeasures" ref="0d49d0d48bae1e33557913d5b46c2c56" args="(CamImage *image, CamMeasuresResults *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMeasures           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamMeasuresResults.html">CamMeasuresResults</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Measures in an image : min, max, average and sum. 
<p>
Average deviation is not measured. See <a class="el" href="camellia_8h.html#55f4073da0fd5b396807694f34351edd" title="Average deviation computation.">camMeasureAverageDeviation()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process (or its ROI) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The <a class="el" href="structCamMeasuresResults.html" title="The structure containing the result of measuring.">CamMeasuresResults</a> structure to be filled. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a73779e31db619f5a35c45b707ee2732"></a><!-- doxytag: member="camellia.h::camMedianFilter3x3" ref="a73779e31db619f5a35c45b707ee2732" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMedianFilter3x3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Median Filtering function 
<p>
For each 3x3 set of pixels, keep the median value. Considered as being a good filter, less sensitive to noise.than linear filtering.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="0d9d8073e45c5f4ddd874acc919e16e7"></a><!-- doxytag: member="camellia.h::camMedianFilter5x5" ref="0d9d8073e45c5f4ddd874acc919e16e7" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMedianFilter5x5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
5x5 Median Filtering function 
<p>
For each 5x5 set of pixels, keep the median value. Considered as being a good filter, less sensitive to noise.than linear filtering.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="893c77311bc86c4e0cd4145e9e4d73c5"></a><!-- doxytag: member="camellia.h::camMonadicArithm" ref="893c77311bc86c4e0cd4145e9e4d73c5" args="(CamImage *source, CamImage *dest, CamArithmParams *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMonadicArithm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamArithmParams.html">CamArithmParams</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the function that implements all the monadic arithmetic operators (i.e. operators with only one operand). 
<p>
This function can be used to compute the absolute value of an image (<code>CAM_ARITHM_ABS</code>), to invert an image (<code>CAM_ARITHM_INVERSE</code>), to select all pixels with a given value in an image (<code>CAM_ARITHM_SELECT</code>), to threshold an image either with one threshold value (<code>CAM_ARITHM_THRESHOLD</code>), or two threshold values (<code>CAM_ARITHM_DOUBLE_THRESHOLD</code>)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. The source must be a grey-level image, except when the operation is an image inversion (<code>CAM_ARITHM_INVERSE</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. The destination image can be either a grey-level image or a binary image. In the latter case, <code>CAM_ARITHM_ABS</code> is not a valid operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamArithmParams.html" title="This is the parameter structure for the arithmetic computation kernel.">CamArithmParams</a> structure, defining all the parameters of the function to apply to the source image.</td></tr>
  </table>
</dl>
Here are the details on the operations and parameters to set in the <a class="el" href="structCamArithmParams.html" title="This is the parameter structure for the arithmetic computation kernel.">CamArithmParams</a> structure :<ul>
<li><code>CAM_ARITHM_ABS</code> : Absolute value computation. <em>pdest=abs(psource)</em>.</li><li><code>CAM_ARITHM_INVERSE</code> : Inverse. <em>pdest=not(psource)</em>.</li><li><code>CAM_ARITHM_SELECT</code> : Selection of a part of an image. <em>if (psource=c1) then pdest=c2 else pdest=c3</em>.</li><li><code>CAM_ARITHM_THRESHOLD</code> : Comparison with a scalar (also called thresholding). <em>if (psource&lt;c1) then pdest=c2 else pdest=c3</em>.</li><li><code>CAM_ARITHM_DOUBLE_THRESHOLD</code> : Double thresholding. <em>if (psource&gt;c1 and psource&lt;c2) then pdest=c3 else pdest=c4</em>.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. An accumulator of all results pixel values otherwise.</dd></dl>
Note that this kernel supports in-place processing (i.e. dest can be the same as source param). 
</div>
</div><p>
<a class="anchor" name="293efc2f56e0b03053570e365fc0186f"></a><!-- doxytag: member="camellia.h::camMorphoGradientCircle5" ref="293efc2f56e0b03053570e365fc0186f" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMorphoGradientCircle5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Morphological gradient computation (Diameter-5 circle structural element). 
<p>
Computes the morphological gradient of an image.<p>
Uses a circular structural element of diameter 5. It is twice faster than the original morpho maths kernel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="f2ea7f9675545d5679c241888c13981c"></a><!-- doxytag: member="camellia.h::camMorphoGradientCircle7" ref="f2ea7f9675545d5679c241888c13981c" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMorphoGradientCircle7           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Morphological gradient computation (Diameter-7 circle structural element). 
<p>
Computes the morphological gradient of an image.<p>
Uses a circular structural element of diameter 7. It is twice faster than the original morpho maths kernel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="2a4c93e9b36955b34685629043ce4de1"></a><!-- doxytag: member="camellia.h::camMorphoGradientSquare3" ref="2a4c93e9b36955b34685629043ce4de1" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMorphoGradientSquare3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Morphological gradient computation (3x3 square structural element). 
<p>
Computes the morphological gradient of an image.<p>
Uses a 3x3 square structural element (very classical). Highly optimized code.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Must be a grey-level image. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be a grey-level image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="52d51b9230e15d3f4de74a5d0a9c6c11"></a><!-- doxytag: member="camellia.h::camMorphoMaths" ref="52d51b9230e15d3f4de74a5d0a9c6c11" args="(CamImage *source, CamImage *dest, CamMorphoMathsKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMorphoMaths           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamMorphoMathsKernel.html">CamMorphoMathsKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the function that can compute erosion AND dilation in one scan (with 5x5 neighborhood). 
<p>
It can be used to compute thinning, thickening, or morphological gradient in one scan. If only erosion or dilation is needed, it's more simple (and a bit faster) to use the dedicated functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamMorphoMathsKernel.html" title="This is the parameter structure for the morpho maths kernel.">CamMorphoMathsKernel</a> structure, defining the structural elements, as well as the behaviour of the kernel. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this kernel supports in-place processing (i.e. dest can be the same as source param) 
</div>
</div><p>
<a class="anchor" name="32b76b2d5b19d62ec552a8bb8ff2e469"></a><!-- doxytag: member="camellia.h::camMul" ref="32b76b2d5b19d62ec552a8bb8ff2e469" args="(CamImage *source1, CamImage *source2, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camMul           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Image multiplication. 
<p>
Simple wrapper for <a class="el" href="camellia_8h.html#92644056e097e0734e774001fbcdcacb" title="This is the function that implements all the dyadic arithmetic operators (i.e. operators...">camDyadicArithm()</a> 
</div>
</div><p>
<a class="anchor" name="7e7bab9a4ef6bc165f2cf12290d014fc"></a><!-- doxytag: member="camellia.h::camPlot" ref="7e7bab9a4ef6bc165f2cf12290d014fc" args="(CamImage *image, int x, int y, int color, int kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camPlot           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Plot. 
<p>
Plots a point (CAM_POINT), a cross (CAM_CROSS), a circle (CAM_CIRCLE) or a combination of them (<code>CAM_CROSS|CAM_CIRCLE</code> for instance) 
</div>
</div><p>
<a class="anchor" name="c5b250ed6063c5813d6ba085e7c7227e"></a><!-- doxytag: member="camellia.h::camRefCopy" ref="c5b250ed6063c5813d6ba085e7c7227e" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRefCopy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reference copy. 
<p>
This function doesn't copy the pixels, only the structure. Destination image will reference the same pixels as the source image. The image will be freed when source will be deallocated through <a class="el" href="camellia_8h.html#f9e0cfd15d26b78ad54684acb9aafb35" title="Image memory release.">camDeallocateImage()</a> function. 
</div>
</div><p>
<a class="anchor" name="f26daf901d61d38ed4b5c2dfe82b9691"></a><!-- doxytag: member="camellia.h::camRGB" ref="f26daf901d61d38ed4b5c2dfe82b9691" args="(int r, int g, int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRGB           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
24 bits integer color representation. Stricly equivalent to the Windows RGB macro. 
<p>
Please use this one in place of RGB for better portability of the code. 
</div>
</div><p>
<a class="anchor" name="7abff958da31df68c1e2e51876303592"></a><!-- doxytag: member="camellia.h::camRLEAllocate" ref="7abff958da31df68c1e2e51876303592" args="(CamRLEImage *rle, int max_runs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEAllocate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>rle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_runs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE Image allocation. 
<p>
Allocates a RLE image.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rle</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> to allocate. The number of runs should be chosen so that it is enough to encode the image to process. A typical value used for this parameter is <code>source.width*source.height/16</code>, assuming a typical run will of length 16. Note that this is very realistic when the original image was thresholded and filtered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_runs</em>&nbsp;</td><td>The number of runs to allocate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs.</dd></dl>
Note that this function uses the standard C <code>malloc()</code> function.<p>
Note also that the amount of memory allocated is <code>8*max_runs</code> bytes. Thus, using the typical <code>max_runs</code> value exposed above, a grey-level image will be compressed by a factor of 2, and a binary image expanded by a factor of 4 using RLE encoding.<p>
The RLE image should be deallocated using the <a class="el" href="camellia_8h.html#2c150b160d28340ece465e8161eb8757" title="RLE image deallocation.">camRLEDeallocate()</a> function, or by calling the standard C function <code>free()</code> on the <code>runs</code> member of the <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> structure. 
</div>
</div><p>
<a class="anchor" name="117c49e467f08ecec1f4f48b8059d37a"></a><!-- doxytag: member="camellia.h::camRLEApplyLUT" ref="117c49e467f08ecec1f4f48b8059d37a" args="(CamRLEImage *src, CamRLEImage *dest, CamTable *LUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEApplyLUT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>LUT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The RLE "Apply a LUT" function. 
<p>
Very useful to post-process a RLE image. This function join runs when needed.<p>
Applying a LUT (i.e. for instance thresholding) can be useful for many purposes (like "several thresholds at once" processing). For experts only.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LUT</em>&nbsp;</td><td>Look-up-table applied to the <code>value</code> member of each run. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7bdba2a8e16e2f3bd55dc8250bbafd39"></a><!-- doxytag: member="camellia.h::camRLEBlobAnalysis" ref="7bdba2a8e16e2f3bd55dc8250bbafd39" args="(CamRLEImage *src, CamBlobs *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEBlobAnalysis           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamBlobs.html">CamBlobs</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The RLE Blob Analysis function. 
<p>
Automatically called by <a class="el" href="camellia_8h.html#348632f8fe184c8a0340d1adaf316e0d" title="RLE image labeling + blob analysis. 4-connectedness labeling.">camRLELabeling()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>, already labelled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The <a class="el" href="structCamBlobs.html" title="The result of any blob analysis. Essentially an array of CamBlobInfo.">CamBlobs</a> containing the results of the blob analysis. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. Generally when the number of blobs exceeds the <code>CAM_LABEL_MAX_BLOBS</code> constant. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f6c8ab5acec8857c8299ba9a9e63fffd"></a><!-- doxytag: member="camellia.h::camRLEClone" ref="f6c8ab5acec8857c8299ba9a9e63fffd" args="(CamRLEImage *source, CamRLEImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEClone           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE image cloning. 
<p>
Clone a RLE image.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> to clone. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> to allocate (shouldn't be allocated) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs.</dd></dl>
Note that this function uses the standard C <code>malloc()</code> function. 
</div>
</div><p>
<a class="anchor" name="2c150b160d28340ece465e8161eb8757"></a><!-- doxytag: member="camellia.h::camRLEDeallocate" ref="2c150b160d28340ece465e8161eb8757" args="(CamRLEImage *rle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEDeallocate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>rle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE image deallocation. 
<p>
Release a RLE image memory. Should be matched with a call to <a class="el" href="camellia_8h.html#7abff958da31df68c1e2e51876303592" title="RLE Image allocation.">camRLEAllocate()</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rle</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> to deallocate. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs.</dd></dl>
Note that this function uses the standard C <code>free()</code> function. 
</div>
</div><p>
<a class="anchor" name="ebccaa8cc9e341ef28bc1184db25ac58"></a><!-- doxytag: member="camellia.h::camRLEDecode" ref="ebccaa8cc9e341ef28bc1184db25ac58" args="(CamRLEImage *src, CamImage *dest, CamTable *LUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEDecode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>LUT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The RLE decoding function. 
<p>
Reconstructs an <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> from runs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be grey-level image (binary image RLE decoding not yet implemented). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LUT</em>&nbsp;</td><td>Look-up-table applied to the <code>value</code> member of each run, to produce the pixel value in the <code>dest</code> image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implement binary image RLE decoding </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b4e74dc430b35b0e7faf5243f705ffd"></a><!-- doxytag: member="camellia.h::camRLEDecodeBlobs" ref="7b4e74dc430b35b0e7faf5243f705ffd" args="(CamRLEImage *src, CamImage *dest, CamTable *LUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEDecodeBlobs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>LUT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Another RLE decoding function, used to retrieve some specific blobs. 
<p>
Reconstructs an <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> from a labelled RLE image. Very useful to see the result of labeling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a>. Must be grey-level image (binary image RLE decoding not yet implemented). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LUT</em>&nbsp;</td><td>Look-up-table applied to the <code>blob</code> member of each run, to produce the pixel value in the <code>dest</code> image. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs.</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Implement binary image RLE decoding </dd></dl>

</div>
</div><p>
<a class="anchor" name="a699c24c3840fca04e838d731aea1b7a"></a><!-- doxytag: member="camellia.h::camRLEEncode" ref="a699c24c3840fca04e838d731aea1b7a" args="(CamImage *src, CamRLEImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEEncode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run-Length encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to encode. This should be either a thresholded image or a binary image. Note that this source image should be filtered (using <a class="el" href="camellia_8h.html#66d45657c1f0d5c57ff29a6db5737124" title="3x3 neighborhood erosion">camErode3x3()</a> for instance) before encoding, in order to avoid a too high number of runs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> resulting of the encoding. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs.</dd></dl>
Note that binary images encoding was optimized. 
</div>
</div><p>
<a class="anchor" name="36b4ca7ddca5c72859d5cb88a3875887"></a><!-- doxytag: member="camellia.h::camRLEEncodeLUT" ref="36b4ca7ddca5c72859d5cb88a3875887" args="(CamImage *src, CamRLEImage *dest, CamTable *LUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEEncodeLUT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>LUT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run-Length encoding, with integrated LUT operations. 
<p>
Introduced v1.9.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to encode. This must be a grey-level image. Note that this source image should be filtered (using <a class="el" href="camellia_8h.html#66d45657c1f0d5c57ff29a6db5737124" title="3x3 neighborhood erosion">camErode3x3()</a> for instance) before encoding, in order to avoid a too high number of runs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> resulting of the encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LUT</em>&nbsp;</td><td>An array of integer used to classify the source image pixels. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="df671bd0479a0f1d78884878a7bdf3c3"></a><!-- doxytag: member="camellia.h::camRLEEncodeThreshold" ref="df671bd0479a0f1d78884878a7bdf3c3" args="(CamImage *src, CamRLEImage *dest, int threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEEncodeThreshold           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run-Length encoding, with integrated thresholding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to encode. This must be a grey-level image. Note that this source image should be filtered (using <a class="el" href="camellia_8h.html#944740494c1d9a5052d7976c1ca7037e" title="Erosion (3x3 square structural element).">camErodeSquare3()</a> for instance) before encoding, in order to avoid a too high number of runs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> resulting of the encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>The threshold used. All pixels with value higher (&gt;=) than threshold will be labelled.. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fab509f921ec4f4a8aef3ef93344347"></a><!-- doxytag: member="camellia.h::camRLEEncodeThresholdInv" ref="2fab509f921ec4f4a8aef3ef93344347" args="(CamImage *src, CamRLEImage *dest, int threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEEncodeThresholdInv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run-Length encoding, with integrated thresholding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to encode. This must be a grey-level image. Note that this source image should be filtered (using <a class="el" href="camellia_8h.html#944740494c1d9a5052d7976c1ca7037e" title="Erosion (3x3 square structural element).">camErodeSquare3()</a> for instance) before encoding, in order to avoid a too high number of runs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> resulting of the encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>The threshold used. All pixels with value lower (&gt;=) than threshold will be labelled.. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="741866f17383569eb9ef8549848d36bd"></a><!-- doxytag: member="camellia.h::camRLEErode3x2" ref="741866f17383569eb9ef8549848d36bd" args="(CamRLEImage *image, CamRLEImage *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEErode3x2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE image erosion (3x2 square structural element). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The source <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The destination <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8204547f72749bab5e21100d07c5d8a"></a><!-- doxytag: member="camellia.h::camRLEErode3x3" ref="b8204547f72749bab5e21100d07c5d8a" args="(CamRLEImage *image, CamRLEImage *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEErode3x3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE image erosion (3x3 square structural element). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The source <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The destination <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e68c93597753418b22d257ede896e4b9"></a><!-- doxytag: member="camellia.h::camRLEErodeCross" ref="e68c93597753418b22d257ede896e4b9" args="(CamRLEImage *image, CamRLEImage *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEErodeCross           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE image erosion (cross structural element). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The source <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The destination <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3916b4991abbef547603dc205381a251"></a><!-- doxytag: member="camellia.h::camRLEInverse" ref="3916b4991abbef547603dc205381a251" args="(CamRLEImage *image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEInverse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE image inversion. 
<p>
Very useful function, for finding holes in blobs. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The source and destination <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a>. In-place processing only. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="348632f8fe184c8a0340d1adaf316e0d"></a><!-- doxytag: member="camellia.h::camRLELabeling" ref="348632f8fe184c8a0340d1adaf316e0d" args="(CamRLEImage *src, CamBlobs *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLELabeling           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamBlobs.html">CamBlobs</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE image labeling + blob analysis. 4-connectedness labeling. 
<p>
Very fast labeling algorithm originally introduced by the Carneggie Mellon University (see below). This function also performs a basic blob analysis<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> to label. Note that the content of <code>src</code> is altered, for RLE labeling is performed in-place. This is what makes it especially fast, since it doesn't require neither an additional label image nor an equivalence table, everything being stored in the <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The <a class="el" href="structCamBlobs.html" title="The result of any blob analysis. Essentially an array of CamBlobInfo.">CamBlobs</a> containing the results of the blob analysis. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. Generally when the number of blobs exceeds the <code>CAM_LABEL_MAX_BLOBS</code> constant.</dd></dl>
This code is based on the ideas developped in the CMVision library by CMU.<p>
<div class="fragment"><pre class="fragment">

 -------------------------------------------------------------------------
  Copyright 1999, 2000         #### ### ### ## ## ## #### ##  ###  ##  ##
  James R. Bruce              ##    ####### ## ## ## ##   ## ## ## ######
  School of Computer Science  ##    ## # ## ## ## ##  ### ## ## ## ## ###
  Carnegie Mellon University   #### ##   ##  ###  ## #### ##  ###  ##  ##
 -------------------------------------------------------------------------

 * </pre></div> 
</div>
</div><p>
<a class="anchor" name="b2e398655ce514efabaf74a2caca3447"></a><!-- doxytag: member="camellia.h::camRLEReallocate" ref="b2e398655ce514efabaf74a2caca3447" args="(CamRLEImage *rle, int new_max_runs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camRLEReallocate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamRLEImage.html">CamRLEImage</a> *&nbsp;</td>
          <td class="paramname"> <em>rle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>new_max_runs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RLE image reallocation. 
<p>
Reallocates a RLE image.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rle</em>&nbsp;</td><td>The <a class="el" href="structCamRLEImage.html" title="The CamRLEImage structure : the RLE (Run Length Encoded) image structure.">CamRLEImage</a> to reallocate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_max_runs</em>&nbsp;</td><td>The new number of allocated runs </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs.</dd></dl>
Note that this function uses the standard C <code>realloc()</code> function. 
</div>
</div><p>
<a class="anchor" name="d35645928b902a2716cd4d3d79799970"></a><!-- doxytag: member="camellia.h::camScale" ref="d35645928b902a2716cd4d3d79799970" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camScale           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scaling function. 
<p>
This function operates a scaling from the source image to the destination image. It can upscale or downscale pictures, and uses bilinear interpolation technique.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to warp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The warped image </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c4ff2c7004422882592e56e30245ae80"></a><!-- doxytag: member="camellia.h::camSepFilter3x3" ref="c4ff2c7004422882592e56e30245ae80" args="(CamImage *source, CamImage *dest, CamSepFilterKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSepFilter3x3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Linear Filtering function with a separable kernel 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamSepFilterKernel.html" title="The parameters structure for linear filtering.">CamSepFilterKernel</a> structure, specifying the separable linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="85fc004b87bd87bdba6bb8a1f597aeb7"></a><!-- doxytag: member="camellia.h::camSepFilter5x5" ref="85fc004b87bd87bdba6bb8a1f597aeb7" args="(CamImage *source, CamImage *dest, CamSepFilterKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSepFilter5x5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
5x5 Linear Filtering function with a separable kernel 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamSepFilterKernel.html" title="The parameters structure for linear filtering.">CamSepFilterKernel</a> structure, specifying the separable linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="bcd6d660fc22ead9c89038345e378b83"></a><!-- doxytag: member="camellia.h::camSepFilter7x7" ref="bcd6d660fc22ead9c89038345e378b83" args="(CamImage *source, CamImage *dest, CamSepFilterKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSepFilter7x7           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
7x7 Linear Filtering function with a separable kernel 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamSepFilterKernel.html" title="The parameters structure for linear filtering.">CamSepFilterKernel</a> structure, specifying the separable linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="d3f008ee8a5885f955273fdcde72a105"></a><!-- doxytag: member="camellia.h::camSepFilterAbs3x3" ref="d3f008ee8a5885f955273fdcde72a105" args="(CamImage *source, CamImage *dest, CamSepFilterKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSepFilterAbs3x3           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Linear Filtering function with a separable kernel (absolute value) 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamSepFilterKernel.html" title="The parameters structure for linear filtering.">CamSepFilterKernel</a> structure, specifying the separable linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="33145b07e332bafe9dad7cee22ead5df"></a><!-- doxytag: member="camellia.h::camSepFilterAbs5x5" ref="33145b07e332bafe9dad7cee22ead5df" args="(CamImage *source, CamImage *dest, CamSepFilterKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSepFilterAbs5x5           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
5x5 Linear Filtering function with a separable kernel (absolute value) 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamSepFilterKernel.html" title="The parameters structure for linear filtering.">CamSepFilterKernel</a> structure, specifying the separable linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="9d331944cb5958c8da918d9f8fa17f87"></a><!-- doxytag: member="camellia.h::camSepFilterAbs7x7" ref="9d331944cb5958c8da918d9f8fa17f87" args="(CamImage *source, CamImage *dest, CamSepFilterKernel *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSepFilterAbs7x7           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamSepFilterKernel.html">CamSepFilterKernel</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
7x7 Linear Filtering function with a separable kernel (absolute value) 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernel</em>&nbsp;</td><td>A pointer to a <a class="el" href="structCamSepFilterKernel.html" title="The parameters structure for linear filtering.">CamSepFilterKernel</a> structure, specifying the separable linear kernel to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Sum (Accumulator) of all computed pixels</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="4bd1a772ca2635653c867ed63abf80d4"></a><!-- doxytag: member="camellia.h::camSobelH" ref="4bd1a772ca2635653c867ed63abf80d4" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSobelH           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Horizontal Sobel Filter. Detects horizontal edges. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the function succeeds. 0 otherwise.</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="42707f0ff29d6e629c46fe1b96b78d20"></a><!-- doxytag: member="camellia.h::camSobelHAbs" ref="42707f0ff29d6e629c46fe1b96b78d20" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSobelHAbs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Horizontal Sobel Filter (absolute). Detects horizontal edges. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the function succeeds. 0 otherwise.</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="925277229ae31d55a76bc54ad8d3f4bd"></a><!-- doxytag: member="camellia.h::camSobelV" ref="925277229ae31d55a76bc54ad8d3f4bd" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSobelV           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Vertical Sobel Filter. Detects Vertical edges. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the function succeeds. 0 otherwise.</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="345e98b33f2ad94c87129acdfc539bfe"></a><!-- doxytag: member="camellia.h::camSobelVAbs" ref="345e98b33f2ad94c87129acdfc539bfe" args="(CamImage *source, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSobelVAbs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
3x3 Vertical Sobel Filter (absolute). Detects Vertical edges. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process. Grey scale only. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the function succeeds. 0 otherwise.</dd></dl>
Note that this function supports in-place processing (i.e. dest can be the same as source param)<p>
Note also that signed saturation is to (-127;+127) instead of the traditional signed char (-128;+127), so that results of filtering are unbiased. 
</div>
</div><p>
<a class="anchor" name="ca659e68abd6449dfdd72070f55f3ef7"></a><!-- doxytag: member="camellia.h::camSub" ref="ca659e68abd6449dfdd72070f55f3ef7" args="(CamImage *source1, CamImage *source2, CamImage *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSub           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Image subtraction. 
<p>
Simple wrapper for <a class="el" href="camellia_8h.html#92644056e097e0734e774001fbcdcacb" title="This is the function that implements all the dyadic arithmetic operators (i.e. operators...">camDyadicArithm()</a> 
</div>
</div><p>
<a class="anchor" name="e7d48717a112c84b2b75e67e012b9cfa"></a><!-- doxytag: member="camellia.h::camSumH" ref="e7d48717a112c84b2b75e67e012b9cfa" args="(CamImage *image, CamTable *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSumH           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Horizontal summing function. 
<p>
Very useful to detect features in images, generally after applying a filter like sobel or morphological gradient.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process (or its ROI) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The <a class="el" href="structCamTable.html" title="Pixel table (LUT (Look-Up Table) and histogram) structure.">CamTable</a> array of integers filled with results. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4ba2c4e9781a3673450d209cc0b67aad"></a><!-- doxytag: member="camellia.h::camSumHV" ref="4ba2c4e9781a3673450d209cc0b67aad" args="(CamImage *image, CamTable *hsum, CamTable *vsum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSumHV           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>hsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>vsum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Horizontal and vertical summing function. 
<p>
Very useful to detect features in images, generally after applying a filter like sobel or morphological gradient.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process (or its ROI) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hsum</em>&nbsp;</td><td>The <a class="el" href="structCamTable.html" title="Pixel table (LUT (Look-Up Table) and histogram) structure.">CamTable</a> array of integers containing the horizontal sum. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vsum</em>&nbsp;</td><td>The <a class="el" href="structCamTable.html" title="Pixel table (LUT (Look-Up Table) and histogram) structure.">CamTable</a> array of integers containing the vertical sum. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3bf851a2a4e3239812265c3500a3465"></a><!-- doxytag: member="camellia.h::camSumV" ref="b3bf851a2a4e3239812265c3500a3465" args="(CamImage *image, CamTable *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camSumV           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamTable.html">CamTable</a> *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vertical summing function. 
<p>
Very useful to detect features in images, generally after applying a filter like sobel or morphological gradient.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to process (or its ROI) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The <a class="el" href="structCamTable.html" title="Pixel table (LUT (Look-Up Table) and histogram) structure.">CamTable</a> array of integers filled with results. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3da02773030098aa2560d20c433508f1"></a><!-- doxytag: member="camellia.h::camThreshold" ref="3da02773030098aa2560d20c433508f1" args="(CamImage *source, CamImage *dest, int threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camThreshold           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple threshold function (wrapper for <a class="el" href="camellia_8h.html#893c77311bc86c4e0cd4145e9e4d73c5" title="This is the function that implements all the monadic arithmetic operators (i.e. operators...">camMonadicArithm()</a> function). 
<p>
Turn all pixels below (&lt;) the threshold value to 0, and all pixels above (&gt;=) to 255 
</div>
</div><p>
<a class="anchor" name="a662752c18c3bef9387a1eeb2de12ac5"></a><!-- doxytag: member="camellia.h::camThresholdInv" ref="a662752c18c3bef9387a1eeb2de12ac5" args="(CamImage *source, CamImage *dest, int threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camThresholdInv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple threshold function (wrapper for <a class="el" href="camellia_8h.html#893c77311bc86c4e0cd4145e9e4d73c5" title="This is the function that implements all the monadic arithmetic operators (i.e. operators...">camMonadicArithm()</a> function). 
<p>
Turn all pixels below (&lt;) the threshold value to 255, and all pixels above (&gt;=) to 0 
</div>
</div><p>
<a class="anchor" name="748bad57cb453f2394a2f2a287993553"></a><!-- doxytag: member="camellia.h::camVolbergFwd" ref="748bad57cb453f2394a2f2a287993553" args="(CamImage *source, CamImage *dest, CamVolbergFwdParams *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void camVolbergFwd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamVolbergFwdParams.html">CamVolbergFwdParams</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function for using Volberg's warping algorithm. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to warp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The warped image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>The camVolbergFwdParams structure providing the mapping functions </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="78547e1ee667ba06ec613ea7e1a9a132"></a><!-- doxytag: member="camellia.h::camVolbergFwdScanline" ref="78547e1ee667ba06ec613ea7e1a9a132" args="(CAM_PIXEL *in, int inlen, CAM_PIXEL *out, int outlen, double f[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void camVolbergFwdScanline           </td>
          <td>(</td>
          <td class="paramtype">CAM_PIXEL *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CAM_PIXEL *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Warping using Volberg's algorithm. 
<p>
This is a forward separable mapping algorithm, i.e. the user must provide two functions that compute the destination points of any source point.<p>
This function is the core function, making a single scanline mapping. It must be called twice to have a full mapping. Use <a class="el" href="camellia_8h.html#748bad57cb453f2394a2f2a287993553" title="Helper function for using Volberg&#39;s warping algorithm.">camVolbergFwd()</a> to do this. 
</div>
</div><p>
<a class="anchor" name="ad957d473fde58077a501728e5aa8f13"></a><!-- doxytag: member="camellia.h::camWarping" ref="ad957d473fde58077a501728e5aa8f13" args="(CamImage *source, CamImage *dest, CamWarpingParams *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camWarping           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamImage.html">CamImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCamWarpingParams.html">CamWarpingParams</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Backward warping function. 
<p>
This function operates a backward mapping from the source image to a destination image. All the params refer to locations in the source image, whereas the ROI scanned by this warping function is set by the <code>roi</code> member of the dest image<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The <a class="el" href="structCamImage.html" title="The famous IplImage/CamImage structure, today&#39;s standard structure for image...">CamImage</a> to warp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The warped image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>The <a class="el" href="structCamWarpingParams.html" title="The parameters structure used by camWarping().">CamWarpingParams</a> structure providing the ROI in the source image (not rectangular) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7d5bb74a1500990197be468f1119f274"></a><!-- doxytag: member="camellia.h::camWatershed1D" ref="7d5bb74a1500990197be468f1119f274" args="(int *input, int size, int *results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int camWatershed1D           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
1D watershed computation 
<p>
Retrieves all the watershed points, along with their depth (i.e. the minimum depth of the 2 catchment bassins contributing to the watershed point).<p>
1D watersheding operation is a very smart way to analyze the results of an histogram (generally before thresholding), yielding better results than a simple n% threshold.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The 1D integer data for which to compute the watershed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the 1D integer array (<code>t</code>). Generally 256 when <code>t</code> is the results of an histogramming operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>The 1D integer array contaning the results of the watershed computation. A value different from 0 indicates a watershed point, the value indicating the depth (and thus the importance) associated to this watershed point. The memory for this array is not allocated by this function, and thus an array of appropriate size must be allocated before calling this function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 (false) if an error occurs </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 3 16:41:07 2008 for Camellia by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
